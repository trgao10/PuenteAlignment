<?xml version="1.0"?>
<!--
  Copyright: $$copyright 
  
  File: consts.xml
  
  Purpose: Lists all constants in Mosek.
  -->


<!--
  This file lists all constants and parameters used in Mosek.


  THE FORMAT OF THIS FILE

  <mosekvalues>
    descr: The document root.
    
  <version>
    elements: <major> <minor> <build> <revision> <state>
    descr: Mosek version corresponding to the content of this file.

  <major>, <minor>, <build>, <revision>
    descr: An Integer representing the version.
    
  <state>
    descr: A string representing the version state 

  <constlist>
    elements: <sec>
    descr: This contains all Mosek constant groups.

  <sec>
    attributes:
      id: The name of the constants group as found in "mosek.h"
      type: String indicating the meaning of the constants. It is
        either "enum" (indicating that the group appears as an enum in
        "mosek.h"), "constants" (meaning a logical grouping of
        constants sharing the same prefix) or "parameter" (represents
        a type of parameters).
    elements: <c> <p>
    descr: Represents a group of constants.

  <c>
    attributes:
      name: The name of the constant
      val: The value of the constant
    elements: <cmnt> <seealso>
    descr: Represents a single constant value.

  <p>
    attributes:
      name: The name of the parameter
      val: The value of the constant representing the parameter (not the value of the parameter)
    elements: <cmnt> <default> <lower_bound> <upper_bound> <values_from> <seealso>
    descr: Represents a single parameter.

  <cmnt>
    descr: Text (LaTeX) description of the item.

  <seealso key="KEY">
    Link to other items relevant for this item. The element is empty.

  <default>
    descr: The default value of a parameter

  <lower_bound>
    descr: The lower bound on values for a parameter

  <upper_bound>
    descr: The upper bound on values for a parameter

  <values_from>
    descr: The parameter takes its values from the constant group of this name.
  -->


<mosekvalues>
<version>
 <major>7</major>
 <minor>1</minor>
 <build>0</build>
 <revision>31</revision>
 <state></state>
</version>

<constlist>
 <sec id="MSKsolveforme" type="constants">
  <c name="MSK_SOLVE_PRIMAL" val="1">
   <cmnt>The optimizer should solve the primal problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_DUAL" val="2">
   <cmnt>The optimizer should solve the dual problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_FREE" val="0">
   <cmnt>The optimizer is free to solve either the primal or
                    the dual problem.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemiteme" type="enum">
  <c name="MSK_PI_VAR" val="0">
   <cmnt>Item is a variable.</cmnt>
  </c>
  <c name="MSK_PI_CONE" val="2">
   <cmnt>Item is a cone.</cmnt>
  </c>
  <c name="MSK_PI_CON" val="1">
   <cmnt>Item is a constraint.</cmnt>
  </c>
 </sec>
 <sec id="MSKaccmodee" type="enum">
  <c name="MSK_ACC_VAR" val="0">
   <cmnt>Access data by columns (variable oriented)</cmnt>
  </c>
  <c name="MSK_ACC_CON" val="1">
   <cmnt>Access data by rows (constraint oriented)</cmnt>
  </c>
 </sec>
 <sec id="MSKsensitivitytypee" type="constants">
  <c name="MSK_SENSITIVITY_TYPE_OPTIMAL_PARTITION" val="1">
   <cmnt>Optimal partition sensitivity analysis is performed.</cmnt>
  </c>
  <c name="MSK_SENSITIVITY_TYPE_BASIS" val="0">
   <cmnt>Basis sensitivity analysis is performed.</cmnt>
  </c>
 </sec>
 <sec id="MSKuploe" type="enum">
  <c name="MSK_UPLO_LO" val="0">
   <cmnt>Lower part.</cmnt>
  </c>
  <c name="MSK_UPLO_UP" val="1">
   <cmnt>Upper part</cmnt>
  </c>
 </sec>
 <sec id="MSKintpnthotstarte" type="enum">
  <c name="MSK_INTPNT_HOTSTART_PRIMAL" val="1">
   <cmnt>The interior-point optimizer exploits the primal solution only.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_NONE" val="0">
   <cmnt>The interior-point optimizer performs a coldstart.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_DUAL" val="2">
   <cmnt>The interior-point optimizer exploits the dual solution only.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_PRIMAL_DUAL" val="3">
   <cmnt>The interior-point optimizer exploits both the primal and dual solution.</cmnt>
  </c>
 </sec>
 <sec id="MSKsparame" type="parameters">
  <p name="MSK_SPAR_PARAM_COMMENT_SIGN" val="9">
   <cmnt>Only the first character in this string is
                    used. It is considered as a start of comment sign
                    in the \mosek{} parameter file. Spaces are ignored
                    in the string.</cmnt>
   <default>"%%"</default>
  </p>
  <p name="MSK_SPAR_MIO_DEBUG_STRING" val="8">
   <cmnt>For internal use only.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_PREFIX" val="3">
   <cmnt>\begin{MSKexcl}{mex:cmdln:lua}
                    Not applicable.
                    \end{MSKexcl}

                    \begin{MSKexcl}{!mex:cmdln:lua}
                    If the function \mskitem{task.relaxprimal} adds new constraints to the problem, then
                    they are prefixed by the value of this parameter.
                    \end{MSKexcl}</cmnt>
   <default>"MSK-"</default>
  </p>
  <p name="MSK_SPAR_BAS_SOL_FILE_NAME" val="0">
   <cmnt>Name of the \comp{bas} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_OBJ_NAME" val="13">
   <cmnt>Name of the free constraint  used as objective function.
                    An empty name means that the first constraint is used as objective function.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_WSUMVIOL" val="5">
   <cmnt>The constraint and variable associated with the total weighted sum of violations
                    are each given the name of this parameter postfixed with \texttt{CON} and \texttt{VAR} respectively.</cmnt>
   <default>"WSUMVIOL"</default>
  </p>
  <p name="MSK_SPAR_FEASREPAIR_NAME_SEPARATOR" val="4">
   <cmnt>\begin{MSKexcl}{mex:cmdln:lua}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln:lua}
                    Separator string for names of constraints and
                    variables generated by
                    \mskitem{task.relaxprimal}.
                    \end{MSKexcl}</cmnt>
   <default>"-"</default>
  </p>
  <p name="MSK_SPAR_PARAM_WRITE_FILE_NAME" val="11">
   <cmnt>The parameter database is written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_INT_SOL_FILE_NAME" val="6">
   <cmnt>Name of the \comp{int} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RHS_NAME" val="15">
   <cmnt>Name of the RHS used.
                    An empty name means that the first RHS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_FILE_NAME" val="22">
   <cmnt>Statistics file name.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_WRITE_LP_GEN_VAR_NAME" val="25">
   <cmnt>Sometimes when an LP file is written additional variables must be inserted.
                    They will have the prefix denoted by this parameter.</cmnt>
   <default>"xmskgen"</default>
  </p>
  <p name="MSK_SPAR_DATA_FILE_NAME" val="1">
   <cmnt>Data are read and written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RAN_NAME" val="14">
   <cmnt>Name of the RANGE vector  used.
                    An empty name means that the first RANGE vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_LOW" val="18">
   <cmnt>A filter used to determine which constraints
                    should be listed in the solution file. A value of ``0.5'' means that
                    all constraints having  \comp{xc[i]&gt;0.5} should be listed, whereas
                    ``+0.5'' means that all constraints having \comp{xc[i]&gt;=blc[i]+0.5} should
                    be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_UPR" val="19">
   <cmnt>A filter  used to determine which constraints
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xc[i]&lt;0.5} should be listed, whereas
                    ``-0.5'' means all constraints having \comp{xc[i]&lt;=buc[i]-0.5} should
                    be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_BOU_NAME" val="12">
   <cmnt>Name of the BOUNDS vector used.
                    An empty name means that the first BOUNDS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_UPR" val="21">
   <cmnt>A filter  used to determine which variables
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xx[j]&lt;0.5} should be printed, whereas
                    ``-0.5'' means all constraints having \comp{xx[j]&lt;=bux[j]-0.5} should
                    be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_NAME" val="24">
   <cmnt>Name used when writing the statistics file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_PARAM_READ_FILE_NAME" val="10">
   <cmnt>Modifications to the parameter
                    database is read from this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_ITR_SOL_FILE_NAME" val="7">
   <cmnt>Name of the \comp{itr} solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_FILE_NAME" val="16">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If defined \mskitem{task.sensitivityreport} reads this file as
                    a sensitivity analysis data file specifying the type of analysis
                    to be done.
                    \end{MSKexcl}</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_DEBUG_FILE_NAME" val="2">
   <cmnt>MOSEK debug file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_KEY" val="23">
   <cmnt>Key used when writing the summary file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_RES_FILE_NAME" val="17">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If this is a nonempty string, then \mskitem{task.sensitivityreport} writes results to this file.
                    \end{MSKexcl}</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_LOW" val="20">
   <cmnt>A filter  used to determine which variables
                     should be listed in the solution file. A value of ``0.5'' means
                    that all constraints having \comp{xx[j]&gt;=0.5} should be listed, whereas
                    ``+0.5'' means that all constraints having \comp{xx[j]&gt;=blx[j]+0.5} should
                    be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
 </sec>
 <sec id="MSKiparame" type="parameters">
  <p name="MSK_IPAR_SIM_STABILITY_PRIORITY" val="169">
   <cmnt>Controls how high priority the numerical stability should be given.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD" val="160">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_AUTO" val="21">
   <cmnt>Controls whether an infeasibility report is automatically
                    produced after the optimization if the problem is primal or dual
                    infeasible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_OPTIMIZER" val="89">
   <cmnt>Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_PSD_ITEMS" val="190">
   <cmnt>If the output format is not compatible with semidefinite problems this parameter controls if the writer ignores the conic parts or produces an error.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LEVEL" val="118">
   <cmnt>Currently not used.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LOG_NONCONVEX" val="57">
   <cmnt>Controls amount of output printed by the nonconvex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MIO_MT_USER_CB" val="88">
   <cmnt>It true user callbacks are called from each thread used by this optimizer. If false the user callback is only called from a single thread.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_USE" val="123">
   <cmnt>Controls whether the presolve is applied to a problem before it is optimized.</cmnt>
   <values_from group="MSKpresolvemodee">
    <ref name="MSK_PRESOLVE_MODE_ON"/>
    <ref name="MSK_PRESOLVE_MODE_OFF"/>
    <ref name="MSK_PRESOLVE_MODE_FREE"/>
   </values_from>
   <default>MSK_PRESOLVE_MODE_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY_OPT" val="64">
   <cmnt>Controls the amount of logging from the optimizers employed during the sensitivity analysis.
                    0 means no logging information is produced.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITG" val="109">
   <cmnt>If \mskitem{iparam.opf_write_solutions} is
                \mskitem{onoffkey.on} and an integer solution is defined,
                write the integer solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_HEAD" val="179">
   <cmnt>Controls whether the header section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_BRANCH_PRIORITIES_USE" val="72">
   <cmnt>Controls whether branching priorities are used by the mixed-integer optimizer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_LEVEL_TREE" val="78">
   <cmnt>Controls the cut level employed by the mixed-integer optimizer at the tree. See \mskitem{iparam.mio_cut_level_root}
                    for an explanation of the parameter values.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_FEASREPAIR_OPTIMIZE" val="18">
   <cmnt>Controls which type of feasibility analysis is to be performed.</cmnt>
   <values_from group="MSKfeasrepairtypee">
    <ref name="MSK_FEASREPAIR_OPTIMIZE_NONE"/>
    <ref name="MSK_FEASREPAIR_OPTIMIZE_COMBINED"/>
    <ref name="MSK_FEASREPAIR_OPTIMIZE_PENALTY"/>
   </values_from>
   <default>MSK_FEASREPAIR_OPTIMIZE_NONE</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_RELAX" val="138">
   <cmnt>If this option is turned on, then mixed integer constraints are ignored when a problem is read.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PARAMETERS" val="106">
   <cmnt>Write a parameter section in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_CON" val="127">
   <cmnt>Expected maximum number of constraints to be read. The option is
                    only used by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_VARIABLES" val="193">
   <cmnt>Controls whether the variables section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_CONCURRENT" val="46">
   <cmnt>Controls amount of output printed
                    by the concurrent optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_INTPNT_ORDER_METHOD" val="32">
   <cmnt>Controls the ordering strategy used by the interior-point
                    optimizer when factorizing the Newton
                    equation system.</cmnt>
   <values_from group="MSKorderingtypee">
    <ref name="MSK_ORDER_METHOD_NONE"/>
    <ref name="MSK_ORDER_METHOD_FORCE_GRAPHPAR"/>
    <ref name="MSK_ORDER_METHOD_APPMINLOC"/>
    <ref name="MSK_ORDER_METHOD_TRY_GRAPHPAR"/>
    <ref name="MSK_ORDER_METHOD_FREE"/>
    <ref name="MSK_ORDER_METHOD_EXPERIMENTAL"/>
   </values_from>
   <default>MSK_ORDER_METHOD_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITR" val="110">
   <cmnt>If \mskitem{iparam.opf_write_solutions} is
                \mskitem{onoffkey.on} and an interior solution is defined,
                write the interior solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY" val="63">
   <cmnt>Controls the amount of logging during the sensitivity analysis. 0: Means
                    no logging information is produced. 1: Timing information is
                    printed. 2: Sensitivity results are printed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_QNZ" val="140">
   <cmnt>Expected maximum number of $Q$ non-zeros to be read. The option is
                     used only by MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>20000</default>
  </p>
  <p name="MSK_IPAR_LOG_INFEAS_ANA" val="53">
   <cmnt>Controls amount of output printed by the infeasibility analyzer procedures. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_SELECTION" val="162">
   <cmnt>Controls the choice of the incoming variable,
                    known as the selection strategy, in the primal
                    simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_CMIR" val="76">
   <cmnt>Controls whether mixed integer rounding cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_CONSTRAINTS" val="191">
   <cmnt>Controls whether the constraint section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_TYPE" val="145">
   <cmnt>Controls which type of sensitivity analysis is to be performed.</cmnt>
   <values_from group="MSKsensitivitytypee">
    <ref name="MSK_SENSITIVITY_TYPE_OPTIMAL_PARTITION"/>
    <ref name="MSK_SENSITIVITY_TYPE_BASIS"/>
   </values_from>
   <default>MSK_SENSITIVITY_TYPE_BASIS</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION" val="150">
   <cmnt>The dual simplex optimizer can use a so-called restricted selection/pricing strategy to
                   chooses the outgoing variable. Hence, if restricted selection is applied, then the dual simplex optimizer first
                   choose a subset of all the potential outgoing variables. Next, for some time it will choose the outgoing
                   variable only among the subset. From time to time the subset is redefined.

                   A larger value of this parameter implies that the optimizer will be more aggressive in its
                   restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO_FREQ" val="56">
   <cmnt>Controls how frequent the mixed-integer optimizer prints the log line. It
                    will print line every time \mskitem{iparam.log_mio_freq} relaxations have been solved.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_BAS" val="108">
   <cmnt>If \mskitem{iparam.opf_write_solutions} is
                \mskitem{onoffkey.on} and a basic solution is defined,
                include the basic solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_ROOT_OPTIMIZER" val="97">
   <cmnt>Controls which optimizer is employed at the root node in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_FREE_CON" val="184">
   <cmnt>Controls whether the free
                    constraints are written to the
                    data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIM_FILL" val="115">
   <cmnt>Controls the maximum amount of fill-in that
                    can be created during the elimination phase
                    of the presolve. This parameter times
                    (\comp{numcon}+\comp{numvar}) denotes the amount of fill-in.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_NONCONVEX_MAX_ITERATIONS" val="101">
   <cmnt>Maximum number of iterations that can be used by the nonconvex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100000</default>
  </p>
  <p name="MSK_IPAR_MIO_LOCAL_BRANCH_NUMBER" val="83">
   <cmnt>Controls the size of the local search space when doing local branching.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES" val="185">
   <cmnt>Controls whether the generic names or user-defined
                    names are used in the data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WARNING_LEVEL" val="177">
   <cmnt>Deprecated and not in use</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_BI_FREQ" val="44">
   <cmnt>Controls how frequent the optimizer
                    outputs information about the basis identification
                    and how frequent the user-defined call-back function
                    is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2500</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX" val="14">
   <cmnt>Priority of the dual simplex algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2</default>
  </p>
  <p name="MSK_IPAR_LOG_PRESOLVE" val="61">
   <cmnt>Controls amount of output printed
                    by the presolve procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_STRICT_FORMAT" val="196">
   <cmnt>Controls whether LP  output files satisfy the LP format strictly.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_CONSTRAINTS" val="201">
   <cmnt>Controls whether the constraint section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_OFF_COL_TRH" val="31">
   <cmnt>Controls how many offending columns are detected in
                  the Jacobian of the constraint matrix.

                  1 means aggressive detection, higher values mean less
                  aggressive detection.

                  0 means no detection.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>40</default>
  </p>
  <p name="MSK_IPAR_READ_ANZ" val="126">
   <cmnt>Expected maximum number of $A$ non-zeros to be read. The option is
                     used only by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100000</default>
  </p>
  <p name="MSK_IPAR_MIO_MODE" val="87">
   <cmnt>Controls whether the optimizer includes
                    the integer restrictions when solving a
                    (mixed) integer optimization problem.</cmnt>
   <values_from group="MSKmiomodee">
    <ref name="MSK_MIO_MODE_IGNORED"/>
    <ref name="MSK_MIO_MODE_LAZY"/>
    <ref name="MSK_MIO_MODE_SATISFIED"/>
   </values_from>
   <default>MSK_MIO_MODE_SATISFIED</default>
  </p>
  <p name="MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER" val="124">
   <cmnt>Controls which optimizer that is used to find the optimal repair.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_READ_LP_DROP_NEW_VARS_IN_BOU" val="133">
   <cmnt>If this option is turned on, \mosek{} will drop variables that are defined for the
                    first time in the bounds section.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM" val="65">
   <cmnt>Controls amount of output printed by the simplex optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_MT_SPINCOUNT" val="100">
   <cmnt>Set the number of iterations to spin before sleeping.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1000000000</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SOLUTION_CALLBACK" val="175">
   <cmnt>Indicates whether solution call-backs will be
                    performed during the optimization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_RINS_MAX_NODES" val="96">
   <cmnt>Controls the maximum number of nodes allowed in each call to the RINS heuristic. The default value of -1
                   means that the value is determined automatically. A value of zero turns off the heuristic.</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING_METHOD" val="167">
   <cmnt>Controls how the problem is scaled
                    before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingmethode">
    <ref name="MSK_SCALING_METHOD_POW2"/>
    <ref name="MSK_SCALING_METHOD_FREE"/>
   </values_from>
   <default>MSK_SCALING_METHOD_POW2</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_FREQ" val="66">
   <cmnt>Controls how frequent the simplex optimizer
                    outputs information about the optimization
                    and how frequent the user-defined call-back function
                    is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS" val="122">
   <cmnt>Controls the maximum number reductions performed by the
                    presolve. The value of the parameter is normally only changed
                    in connection with debugging. A negative value implies that an
                    infinite number of reductions are allowed.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_QUOTED_NAMES" val="195">
   <cmnt>If this option is turned on, then \mosek{} will quote invalid LP names when
                  writing an LP file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_FACTOR" val="49">
   <cmnt>If turned on, then the factor log lines are added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_AUTO_UPDATE_SOL_INFO" val="4">
   <cmnt>Controls whether the solution information items are automatically updated after an optimization is performed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_WIDTH" val="139">
   <cmnt>Controls the maximal number of characters allowed in one line of the MPS file.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_TIMING_LEVEL" val="176">
   <cmnt>Controls the a amount of timing performed inside \mosek{}.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_ORDER" val="59">
   <cmnt>If turned on, then factor lines are added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_LEVEL_ROOT" val="77">
   <cmnt>Controls the cut level employed by the mixed-integer optimizer at the root node.
                    A negative value means a default value determined by the mixed-integer optimizer
                    is used. By adding the appropriate values from the following table the
                    employed cut types can be controlled.

                    %inline the file "../shared/miocutlevel.tex"
                    \begin{tabular}{ll}
                    GUB cover        &amp; +2\\
                    Flow cover       &amp; +4 \\
                    Lifting          &amp; +8 \\
                    Plant location   &amp; +16\\
                    Disaggregation   &amp; +32\\
                    Knapsack cover   &amp; +64\\
                    Lattice          &amp; +128\\
                    Gomory           &amp; +256\\
                    Coefficient reduction &amp; +512\\
                    GCD                   &amp; +1024 \\
                    Obj. integrality      &amp; +2048\\
                    \end{tabular}</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_IGN_ERROR" val="114">
   <cmnt>If turned on, then errors in paramter settings is ignored.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE" val="5">
   <cmnt>\begin{MSKexcl}{!lua}
                  If a slack variable is in the basis, then the
                  corresponding column in the basis is a unit vector
                  with -1 in the right position. However, if this
                  parameter is set to \mskitem{onoffkey.on},
                  -1 is replaced by 1.
                  \end{MSKexcl}

                  \begin{MSKexcl}{!mex:cmdln:lua}

                  This has siginificance for the
                  results returned by the
                  \mskitem{task.solvewithbasis} function.
                  \end{MSKexcl}

                  \begin{MSKexcl}{lua}
                  Unused.
                  \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_NUM_ERROR" val="8">
   <cmnt>If the parameter \mskitem{iparam.intpnt_basis} has the value \mskitem{basindtype.no_error}
                   and the interior-point optimizer has terminated due to a numerical problem, then basis identification is performed if this parameter has
                   the value \mskitem{onoffkey.on}.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_SELECTION" val="90">
   <cmnt>Controls the node selection strategy employed by the
                    mixed-integer optimizer.</cmnt>
   <values_from group="MSKmionodeseltypee">
    <ref name="MSK_MIO_NODE_SELECTION_PSEUDO"/>
    <ref name="MSK_MIO_NODE_SELECTION_HYBRID"/>
    <ref name="MSK_MIO_NODE_SELECTION_FREE"/>
    <ref name="MSK_MIO_NODE_SELECTION_WORST"/>
    <ref name="MSK_MIO_NODE_SELECTION_BEST"/>
    <ref name="MSK_MIO_NODE_SELECTION_FIRST"/>
   </values_from>
   <default>MSK_MIO_NODE_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_PRINT_VIOLATED" val="2">
   <cmnt>\begin{MSKexcl}{!cmdln:mex}
                   Controls whether a list of violated constraints is printed when calling \mskitem{task.analyzesolution}.
                   All constraints violated by more than the value set by the parameter  \mskitem{dparam.ana_sol_infeas_tol} will be printed.
                  \end{MSKexcl}
                  \begin{MSKexcl}{cmdln:mex}
                  Controls whether a list of violated constraints is printed.
                  \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_WIDTH" val="174">
   <cmnt>Controls the maximal acceptable width of line in the solutions when read by \mosek.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS" val="30">
   <cmnt>Maximum number of steps to be used by the iterative
                  refinement of the search direction. A negative value
                  implies that the optimizer Chooses the maximum number
                  of iterative refinement steps.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_MINOR" val="67">
   <cmnt>Currently not in use.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_ITERATIONS" val="156">
   <cmnt>Maximum number of iterations that can be used by a
                    simplex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000000</default>
  </p>
  <p name="MSK_IPAR_MIO_PROBING_LEVEL" val="95">
   <cmnt>Controls the amount of probing employed by the mixed-integer
                    optimizer in presolve.
                    
                    \begin{itemize}
                    \item{-1 The optimizer chooses the level of probing employed. } 
                    \item{0 Probing is disabled. }  
                    \item{1 A low amount of probing is employed. }
                    \item{2 A medium amount of probing is employed. }
                    \item{3 A high amount of probing is employed. }
                    \end{itemize}</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_ITERATIONS" val="28">
   <cmnt>Controls the maximum number of iterations
                    allowed in the interior-point optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>400</default>
  </p>
  <p name="MSK_IPAR_CACHE_LICENSE" val="10">
   <cmnt>Specifies if the license is kept checked out for the lifetime of the
                    mosek environment (on) or returned to the server immediately after the optimization (off).

                    \begin{MSKexcl}{c}
                    By default the license is checked out for the lifetime of the \mosek{}
                    environment by the first call to \mskitem{task.optimizetrm}.
                    The license is checked in when \mskitem{env.deleteenv} is called.

                    A specific license feature may be checked in when not in use with the function
                    \mskitem{env.checkinlicense}.
                    \end{MSKexcl}

                    \begin{MSKexcl}{java:dotnet}
                    By default the license is checked out for the lifetime of the \mosek{}
                    environment by the first call to \mskitem{task.optimizetrm}.
                    The license is checked in when the environment is deleted.

                    A specific license feature may be checked in when not in use with the function
                    \mskitem{env.checkinlicense}.
                    \end{MSKexcl}

                    Check-in and check-out of licenses have an overhead.
                    Frequent communication with the license server should be avoided.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_BI" val="43">
   <cmnt>Controls the amount of output printed
                    by the basis identification procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_COR" val="29">
   <cmnt>Controls the maximum number of correctors allowed
                     by the multiple corrector procedure. A
                    negative value means that \mosek{} is making the
                    choice.</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_LINE_WIDTH" val="194">
   <cmnt>Maximum width of line in an LP file written by \mosek{}.</cmnt>
   <lower_bound>40</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>80</default>
  </p>
  <p name="MSK_IPAR_COMPRESS_STATFILE" val="12">
   <cmnt>Control compression of stat files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_NAME_WIDTH" val="173">
   <cmnt>When a solution is read by \mosek{} and some constraint, variable or cone names
                    contain blanks, then a maximum name width much be specified. A negative value implies
                    that no name contain blanks.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LICENSE_DEBUG" val="38">
   <cmnt>This option is used to turn on debugging of the incense manager.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LIC_TRH_EXPIRY_WRN" val="37">
   <cmnt>If a license feature expires in a numbers days less than the value of this parameter then a warning will be issued.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>7</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_BASIS" val="1">
   <cmnt>Controls whether the basis matrix is analyzed in solaution analyzer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES" val="116">
   <cmnt>Control the maximum number of times the eliminator is tried.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES_IO" val="186">
   <cmnt>Index origin used in  generic names.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_NUM_OPTIMIZERS" val="13">
   <cmnt>The maximum number of simultaneous optimizations that will be started
                    by the concurrent optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2</default>
  </p>
  <p name="MSK_IPAR_SIM_REFACTOR_FREQ" val="163">
   <cmnt>Controls how frequent the basis is refactorized.
                    The value 0 means that the optimizer determines
                    the best point of refactorization.

                    It is strongly recommended NOT to change this parameter.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_SELECTION" val="151">
   <cmnt>Controls the choice of the incoming variable,
                    known as the selection strategy, in the dual
                    simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_SOLVE_FORM" val="168">
   <cmnt>Controls whether the primal or the dual problem is solved by the primal-/dual- simplex optimizer.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
    <ref name="MSK_SOLVE_FREE"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_CHECK_CONVEXITY" val="11">
   <cmnt>Specify the level of convexity check on quadratic problems</cmnt>
   <values_from group="MSKcheckconvexitytypee">
    <ref name="MSK_CHECK_CONVEXITY_SIMPLE"/>
    <ref name="MSK_CHECK_CONVEXITY_NONE"/>
    <ref name="MSK_CHECK_CONVEXITY_FULL"/>
   </values_from>
   <default>MSK_CHECK_CONVEXITY_FULL</default>
  </p>
  <p name="MSK_IPAR_QO_SEPARABLE_REFORMULATION" val="125">
   <cmnt>Determine if Quadratic programing problems should be reformulated to separable form.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS" val="188">
   <cmnt>Controls if the writer ignores incompatible problem items when writing files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_TASK_IGNORE_PARAM" val="141">
   <cmnt>Controls whether \mosek{} should ignore the parameter setting defined in the task file and use the
                    default parameter setting instead.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_OPTIMIZER_MODE" val="91">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_INTPNT" val="54">
   <cmnt>Controls amount of output printed printed
                    by the interior-point optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO" val="55">
   <cmnt>Controls the log level for the mixed-integer optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART" val="153">
   <cmnt>Controls the type of hot-start that the simplex optimizer perform.</cmnt>
   <values_from group="MSKsimhotstarte">
    <ref name="MSK_SIM_HOTSTART_NONE"/>
    <ref name="MSK_SIM_HOTSTART_STATUS_KEYS"/>
    <ref name="MSK_SIM_HOTSTART_FREE"/>
   </values_from>
   <default>MSK_SIM_HOTSTART_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG_PARAM" val="60">
   <cmnt>Controls the amount of information printed out about parameter changes.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_FORMAT" val="182">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                Controls the file format when writing task data to a file.
                \end{MSKexcl}

                \begin{MSKexcl}{!mex:cmdln}
                Controls the data format when a task is written using
                \mskitem{task.writedata}.
                \end{MSKexcl}</cmnt>
   <values_from group="MSKdataformate">
    <ref name="MSK_DATA_FORMAT_XML"/>
    <ref name="MSK_DATA_FORMAT_TASK"/>
    <ref name="MSK_DATA_FORMAT_EXTENSION"/>
    <ref name="MSK_DATA_FORMAT_CB"/>
    <ref name="MSK_DATA_FORMAT_FREE_MPS"/>
    <ref name="MSK_DATA_FORMAT_LP"/>
    <ref name="MSK_DATA_FORMAT_OP"/>
    <ref name="MSK_DATA_FORMAT_MPS"/>
   </values_from>
   <default>MSK_DATA_FORMAT_EXTENSION</default>
  </p>
  <p name="MSK_IPAR_SIM_EXPLOIT_DUPVEC" val="152">
   <cmnt>Controls if the simplex optimizers are allowed to exploit duplicated columns.</cmnt>
   <values_from group="MSKsimdupvece">
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_ON"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_OFF"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_FREE"/>
   </values_from>
   <default>MSK_SIM_EXPLOIT_DUPVEC_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_BRANCH_DIR" val="71">
   <cmnt>Controls whether the mixed-integer optimizer is branching up or down by default.</cmnt>
   <values_from group="MSKbranchdire">
    <ref name="MSK_BRANCH_DIR_DOWN"/>
    <ref name="MSK_BRANCH_DIR_UP"/>
    <ref name="MSK_BRANCH_DIR_FREE"/>
   </values_from>
   <default>MSK_BRANCH_DIR_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_FACTOR_DEBUG_LVL" val="25">
   <cmnt>Controls factorization debug level.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LICENSE_PAUSE_TIME" val="39">
   <cmnt>If \mskitem{iparam.license_wait}=\mskitem{onoffkey.on} and no license is available,  then \mosek{} sleeps a number
                    of milliseconds between each check of whether a license has become free.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1000000</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_AGGREGATE" val="92">
   <cmnt>Controls whether the presolve used by the mixed-integer
                    optimizer tries to aggregate the constraints.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_TASK_INC_SOL" val="205">
   <cmnt>Controls whether the solutions are  stored in the task file too.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_BI_MAX_ITERATIONS" val="9">
   <cmnt>Controls the maximum number of
                    simplex iterations allowed to optimize
                    a basis after the basis identification.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000000</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART_LU" val="154">
   <cmnt>Determines if the simplex optimizer should exploit the initial factorization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH" val="120">
   <cmnt>The linear dependency check is potentially computationally expensive.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOLUTIONS" val="111">
   <cmnt>Enable inclusion of solutions in the OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_FEAS_REPAIR" val="50">
   <cmnt>Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_USE" val="121">
   <cmnt>Controls whether the linear constraints are checked for linear dependencies.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_HOTSTART" val="27">
   <cmnt>Currently not in use.</cmnt>
   <values_from group="MSKintpnthotstarte">
    <ref name="MSK_INTPNT_HOTSTART_PRIMAL"/>
    <ref name="MSK_INTPNT_HOTSTART_NONE"/>
    <ref name="MSK_INTPNT_HOTSTART_DUAL"/>
    <ref name="MSK_INTPNT_HOTSTART_PRIMAL_DUAL"/>
   </values_from>
   <default>MSK_INTPNT_HOTSTART_none</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HEADER" val="104">
   <cmnt>Write a text header with date and MOSEK version in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_CONT_SOL" val="74">
   <cmnt>Controls the meaning of the interior-point and basic solutions in mixed integer problems.</cmnt>
   <values_from group="MSKmiocontsoltypee">
    <ref name="MSK_MIO_CONT_SOL_ITG"/>
    <ref name="MSK_MIO_CONT_SOL_NONE"/>
    <ref name="MSK_MIO_CONT_SOL_ROOT"/>
    <ref name="MSK_MIO_CONT_SOL_ITG_REL"/>
   </values_from>
   <default>MSK_MIO_CONT_SOL_NONE</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_HEAD" val="192">
   <cmnt>Controls whether the header section is written to the
                    integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_STARTING_POINT" val="36">
   <cmnt>Starting point used by the interior-point optimizer.</cmnt>
   <values_from group="MSKstartpointtypee">
    <ref name="MSK_STARTING_POINT_GUESS"/>
    <ref name="MSK_STARTING_POINT_SATISFY_BOUNDS"/>
    <ref name="MSK_STARTING_POINT_CONSTANT"/>
    <ref name="MSK_STARTING_POINT_FREE"/>
   </values_from>
   <default>MSK_STARTING_POINT_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_BARVARIABLES" val="200">
   <cmnt>Controls whether the symmetric matrix variables section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_NUM_SETBACKS" val="157">
   <cmnt>Controls how many set-backs are allowed within a simplex
                    optimizer. A set-back is an event where the optimizer moves in
                    the wrong direction. This is impossible in theory but may happen due
                    to numerical problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>250</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX" val="17">
   <cmnt>Priority of the primal simplex algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_OBJ_SENSE" val="137">
   <cmnt>If turned on, the MPS reader uses the objective sense section. Otherwise the MPS reader ignores it.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_NETWORK_FREQ" val="68">
   <cmnt>Controls how frequent the network simplex optimizer
                    outputs information about the optimization
                    and how frequent the user-defined call-back function
                    is called. The network optimizer will use a logging frequency equal to
                    \mskitem{iparam.log_sim_freq} times \mskitem{iparam.log_sim_network_freq}.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_IPAR_INTPNT_DIFF_STEP" val="24">
   <cmnt>Controls whether different step sizes
                    are allowed in the primal and dual space.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING" val="166">
   <cmnt>Controls how much effort is used in scaling the problem
                    before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
    <ref name="MSK_SCALING_FREE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_TERMS_PER_LINE" val="197">
   <cmnt>Maximum number of terms on a single line in an LP file written by \mosek{}.
                    0 means unlimited.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_ALL" val="143">
   <cmnt>\begin{MSKexcl}{mex:cmdln}
                    Not applicable.
                    \end{MSKexcl}
                    \begin{MSKexcl}{!mex:cmdln}
                    If set to \mskitem{onoffkey.on}, then \mskitem{task.sensitivityreport} analyzes all
                    bounds and variables instead of reading a specification from the file.
                    \end{MSKexcl}</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_CONIC_ITEMS" val="187">
   <cmnt>If the output format is not compatible with conic quadratic problems this parameter controls if the writer ignores the conic parts or produces an error.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_MAX_ITER" val="7">
   <cmnt>If the parameter
                   \mskitem{iparam.intpnt_basis} has the
                   value \mskitem{basindtype.no_error} and
                   the interior-point optimizer has terminated due to
                   maximum number of iterations, then basis
                   identification is performed if this parameter has
                   the value \mskitem{onoffkey.on}.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH" val="119">
   <cmnt>The linear dependency check is potentially computationally expensive.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SOLVE_FORM" val="35">
   <cmnt>Controls whether the primal
                    or the dual problem is solved.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
    <ref name="MSK_SOLVE_FREE"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_MAX_TERMS_PER_LINE" val="103">
   <cmnt>The maximum number of terms (linear and quadratic) per line when an OPF file is written.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>5</default>
  </p>
  <p name="MSK_IPAR_WRITE_PRECISION" val="199">
   <cmnt>Controls the precision with which \comp{double}
                    numbers are printed in the MPS data file. In general it
                    is not worthwhile to use a value higher than 15.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>8</default>
  </p>
  <p name="MSK_IPAR_SIM_BASIS_FACTOR_USE" val="146">
   <cmnt>Controls whether a (LU) factorization of the basis is used in a hot-start.
                    Forcing a refactorization sometimes improves the stability of the simplex optimizers, but in most cases
                    there is a performance penanlty.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_XML_MODE" val="206">
   <cmnt>Controls if linear coefficients should be written by row or column when writing in the XML file format.</cmnt>
   <values_from group="MSKxmlwriteroutputtypee">
    <ref name="MSK_WRITE_XML_MODE_COL"/>
    <ref name="MSK_WRITE_XML_MODE_ROW"/>
   </values_from>
   <default>MSK_WRITE_XML_MODE_ROW</default>
  </p>
  <p name="MSK_IPAR_INTPNT_REGULARIZATION_USE" val="33">
   <cmnt>Controls whether regularization is allowed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_BI_CLEAN_OPTIMIZER" val="6">
   <cmnt>Controls which simplex optimizer is used in the clean-up phase.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_PROBING" val="93">
   <cmnt>Controls whether the mixed-integer presolve
                    performs probing. Probing can be very time consuming.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INFEAS_PREFER_PRIMAL" val="20">
   <cmnt>If both certificates of primal and dual infeasibility are supplied then
                    only the primal is used when this option is turned on.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_NL_ITEMS" val="189">
   <cmnt>Controls if the writer ignores general non-linear terms or produces an error.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_VARIABLES" val="180">
   <cmnt>Controls whether the variables section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_STORAGE" val="69">
   <cmnt>When turned on, \mosek{} prints messages regarding
                    the storage usage and allocation.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_PRESOLVE_USE" val="94">
   <cmnt>Controls whether presolve is performed by the mixed-integer optimizer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_LP_QUOTED_NAMES" val="134">
   <cmnt>If a name is in quotes when reading an LP file, the quotes will be removed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_BASIS" val="23">
   <cmnt>Controls whether the interior-point optimizer also
                    computes an optimal basis.</cmnt>
   <values_from group="MSKbasindtypee">
    <ref name="MSK_BI_ALWAYS"/>
    <ref name="MSK_BI_NO_ERROR"/>
    <ref name="MSK_BI_NEVER"/>
    <ref name="MSK_BI_IF_FEASIBLE"/>
    <ref name="MSK_BI_RESERVERED"/>
   </values_from>
   <default>MSK_BI_ALWAYS</default>
   <seealso key="MSK_IPAR_BI_IGNORE_MAX_ITER"/>
   <seealso key="MSK_IPAR_BI_IGNORE_NUM_ERROR"/>
  </p>
  <p name="MSK_IPAR_LOG_CUT_SECOND_OPT" val="47">
   <cmnt>If a task is employed to solve a sequence of optimization problems, then the value of the log levels is reduced by the value
                  of this parameter. E.g \mskitem{iparam.log} and \mskitem{iparam.log_sim} are reduced by the value of this parameter
                  for the second and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
   <seealso key="MSK_IPAR_LOG"/>
   <seealso key="MSK_IPAR_LOG_INTPNT"/>
   <seealso key="MSK_IPAR_LOG_MIO"/>
   <seealso key="MSK_IPAR_LOG_SIM"/>
  </p>
  <p name="MSK_IPAR_READ_MPS_KEEP_INT" val="136">
   <cmnt>Controls whether \mosek{} should keep the integer restrictions
                    on the variables while reading the MPS file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_SOLUTIONS" val="86">
   <cmnt>The mixed-integer optimizer can be terminated after a certain number of different feasible
                    solutions has been located. If this parameter has the value $n$ and $n$ is strictly positive, then the mixed-integer optimizer
                    will be terminated when $n$ feasible solutions have been located.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
   <seealso key="MSK_DPAR_MIO_DISABLE_TERM_TIME"/>
  </p>
  <p name="MSK_IPAR_READ_DEBUG" val="131">
   <cmnt>Turns on additional debugging information when reading files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_VARIABLES" val="204">
   <cmnt>Controls whether the variables section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_OPTIMIZER" val="144">
   <cmnt>Controls which optimizer is used for optimal partition sensitivity analysis.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE_SIMPLEX</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_INT" val="198">
   <cmnt>Controls if  marker records are written to the MPS file
                    to indicate whether variables are integer restricted.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LICENSE_WAIT" val="41">
   <cmnt>If all licenses are in use \mosek{} returns with an error code.
                    However, by turning on this parameter \mosek{} will wait for an available license.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX" val="15">
   <cmnt>Priority of the free simplex optimizer when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>3</default>
  </p>
  <p name="MSK_IPAR_READ_KEEP_FREE_CON" val="132">
   <cmnt>Controls whether the free constraints are included in
                    the problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_FILE" val="51">
   <cmnt>If turned on, then some log info is printed when a file is written or read.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CONCURRENT_PRIORITY_INTPNT" val="16">
   <cmnt>Priority of the interior-point algorithm when selecting solvers for
                    concurrent optimization.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_SIM_NON_SINGULAR" val="158">
   <cmnt>Controls if the simplex optimizer ensures a non-singular basis, if possible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_PARAM" val="183">
   <cmnt>If this option is turned on the parameter settings are written to the
                    data file as parameters.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_DEGEN" val="147">
   <cmnt>Controls how aggressively degeneration is handled.</cmnt>
   <values_from group="MSKsimdegene">
    <ref name="MSK_SIM_DEGEN_NONE"/>
    <ref name="MSK_SIM_DEGEN_MODERATE"/>
    <ref name="MSK_SIM_DEGEN_MINIMUM"/>
    <ref name="MSK_SIM_DEGEN_AGGRESSIVE"/>
    <ref name="MSK_SIM_DEGEN_FREE"/>
   </values_from>
   <default>MSK_SIM_DEGEN_FREE</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HINTS" val="105">
   <cmnt>Write a hint section with problem dimensions in the beginning of an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_USE" val="117">
   <cmnt>Controls whether free or implied free
                    variables are eliminated from the problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_ALLOC_ADD_QNZ" val="0">
   <cmnt>Additional number of $Q$ non-zeros that are allocated space for when \comp{numanz} exceeds \comp{maxnumqnz}
                    during addition of new $Q$ entries.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>5000</default>
  </p>
  <p name="MSK_IPAR_MIO_HOTSTART" val="81">
   <cmnt>Controls whether the integer optimizer is hot-started.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_FORMAT" val="135">
   <cmnt>Controls how strictly the MPS file reader interprets the MPS format.</cmnt>
   <values_from group="MSKmpsformate">
    <ref name="MSK_MPS_FORMAT_STRICT"/>
    <ref name="MSK_MPS_FORMAT_RELAXED"/>
    <ref name="MSK_MPS_FORMAT_FREE"/>
   </values_from>
   <default>MSK_MPS_FORMAT_RELAXED</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_CASE_NAME" val="113">
   <cmnt>If turned on, then names in the parameter file are case sensitive.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_OPTIMIZER" val="58">
   <cmnt>Controls the amount of general optimizer information that is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_BRANCHES" val="84">
   <cmnt>Maximum number of branches allowed during the branch and bound search. A negative
                    value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
   <seealso key="MSK_DPAR_MIO_DISABLE_TERM_TIME"/>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_CRASH" val="159">
   <cmnt>Controls whether crashing is performed in the primal simplex optimizer.

                    In general, if a basis consists of more than (100-this parameter value)\%
                    fixed variables, then a crash will be performed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_MIO_CONSTRUCT_SOL" val="73">
   <cmnt>If set to \mskitem{onoffkey.on} and all integer variables have been given a
                    value for which a feasible mixed integer solution exists, then \mosek{}
                    generates an initial solution to the mixed integer problem by fixing all integer
                    values and solving the remaining problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_AUTO_SORT_A_BEFORE_OPT" val="3">
   <cmnt>Controls whether the elements in each column of $A$ are sorted before an optimization is performed.
                       This is not required but makes the optimization more deterministic.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_STRONG_BRANCH" val="98">
   <cmnt>The value specifies the depth from the root in which strong branching is used.
                    A negative value means that the optimizer chooses a default value automatically.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_PHASEONE_METHOD" val="149">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_INTEGER" val="155">
   <cmnt>An exprimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_USE_MULTITHREADED_OPTIMIZER" val="99">
   <cmnt>Controls wheter the new multithreaded optimizer should be used for Mixed integer problems.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION" val="161">
   <cmnt>The primal simplex optimizer can use a so-called restricted selection/pricing strategy to
                   chooses the outgoing variable. Hence, if restricted selection is applied, then the primal simplex optimizer first
                   choose a subset of all the potential incoming variables. Next, for some time it will choose the incoming
                   variable only among the subset. From time to time the subset is redefined.

                   A larger value of this parameter implies that the optimizer will be more aggressive in its
                   restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_READ_CONE" val="128">
   <cmnt>Expected maximum number of conic constraints to be read. The option is
                     used only by fast MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2500</default>
  </p>
  <p name="MSK_IPAR_OPTIMIZER" val="112">
   <cmnt>The paramter controls which optimizer is used to optimize the task.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONCURRENT"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT_CONIC"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_NONCONVEX"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MAX_NUM_WARNINGS" val="70">
   <cmnt>A negtive number means all warnings are logged. Otherwise the parameter specifies the maximum number 
                times each warning is logged.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>6</default>
  </p>
  <p name="MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS" val="40">
   <cmnt>Controls whether license features expire warnings are suppressed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_CG" val="75">
   <cmnt>Controls whether CG cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES" val="203">
   <cmnt>Even if the names are invalid MPS names, then they are employed when writing the solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_HEAD" val="202">
   <cmnt>Controls whether the header section is written to the
                    solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_CONSTRAINTS" val="178">
   <cmnt>Controls whether the constraint section is written to the
                    basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_LOG_EXPAND" val="48">
   <cmnt>Controls the amount of logging when a data item such as the maximum number constrains is expanded.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_FEASPUMP_LEVEL" val="79">
   <cmnt>Feasibility pump is a heuristic designed to compute an initial feasible solution.
                A value of 0 implies that the feasibility pump heuristic is not used. A value of -1 implies that the mixed-integer
                optimizer decides how the feasibility pump heuristic is used. A larger value than 1 implies that the feasibility pump is
                employed more aggressively. Normally a value beyond 3 is not worthwhile.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>3</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_INFEAS_GENERIC_NAMES" val="19">
   <cmnt>Controls whether generic names are used when an infeasible subproblem is created.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_RESPONSE" val="62">
   <cmnt>Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG" val="42">
   <cmnt>Controls the amount of log information. The value 0 implies that all log information is suppressed.
                  A higher level implies that more information is logged.

                  Please note  that if a task is employed to solve a sequence of optimization problems the value of
                  this parameter is reduced by the value of \mskitem{iparam.log_cut_second_opt} for the second
                  and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
   <seealso key="MSK_IPAR_LOG_CUT_SECOND_OPT"/>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_LEVEL" val="22">
   <cmnt>Controls the amount of information presented in an infeasibility report.
                    Higher values imply more information.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_COMPRESSED" val="181">
   <cmnt>Controls whether the data file is compressed while it is written.
                    $0$ means no compression while higher values mean more compression.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_SWITCH_OPTIMIZER" val="170">
   <cmnt>The simplex optimizer sometimes chooses to solve the dual problem instead of the primal problem.
                   This implies that if you have chosen to use the dual simplex optimizer and the problem is dualized,
                   then it actually makes sense to use the primal simplex optimizer instead. If this parameter is on
                   and the problem is dualized and furthermore the simplex optimizer is chosen to be the primal (dual) one,
                   then it is switched to the dual (primal).</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_DATA_COMPRESSED" val="129">
   <cmnt>If this option is turned on,it is assumed that the data file is compressed.</cmnt>
   <values_from group="MSKcompresstypee">
    <ref name="MSK_COMPRESS_GZIP"/>
    <ref name="MSK_COMPRESS_NONE"/>
    <ref name="MSK_COMPRESS_FREE"/>
   </values_from>
   <default>MSK_COMPRESS_FREE</default>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_RANGED" val="172">
   <cmnt>If turned on, then ranged constraints and variables are written to the solution file
                  independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PROBLEM" val="107">
   <cmnt>Write objective, constraints, bounds etc. to an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_NUM_THREADS" val="102">
   <cmnt>Controls the number of threads employed by the optimizer. If set to 0 the number of threads used will
                    be equal to the number of cores detected on the machine.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_CHECK_CONVEXITY" val="45">
   <cmnt>Controls logging in convexity check on quadratic problems.
                    Set to a positive value to turn logging on.

                    If a quadratic coefficient matrix is found to violate the requirement of PSD (NSD)
                    then a list of negative (positive) pivot elements is printed. The absolute value of the pivot elements
                    is also shown.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_READ_DATA_FORMAT" val="130">
   <cmnt>Format of the data file to be read.</cmnt>
   <values_from group="MSKdataformate">
    <ref name="MSK_DATA_FORMAT_XML"/>
    <ref name="MSK_DATA_FORMAT_TASK"/>
    <ref name="MSK_DATA_FORMAT_EXTENSION"/>
    <ref name="MSK_DATA_FORMAT_CB"/>
    <ref name="MSK_DATA_FORMAT_FREE_MPS"/>
    <ref name="MSK_DATA_FORMAT_LP"/>
    <ref name="MSK_DATA_FORMAT_OP"/>
    <ref name="MSK_DATA_FORMAT_MPS"/>
   </values_from>
   <default>MSK_DATA_FORMAT_EXTENSION</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_CRASH" val="148">
   <cmnt>Controls whether crashing is performed in the dual simplex optimizer.

                    In general if a basis consists of more than (100-this parameter value)\%
                    fixed variables, then a crash will be performed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_READ_VAR" val="142">
   <cmnt>Expected maximum number of variable to be read. The option is
                    used only by MPS and LP file readers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000</default>
  </p>
  <p name="MSK_IPAR_LOG_HEAD" val="52">
   <cmnt>If turned on, then a header line is added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_SIM_REFORMULATION" val="164">
   <cmnt>Controls if the simplex optimizers are allowed to reformulate the problem.</cmnt>
   <values_from group="MSKsimreforme">
    <ref name="MSK_SIM_REFORMULATION_ON"/>
    <ref name="MSK_SIM_REFORMULATION_AGGRESSIVE"/>
    <ref name="MSK_SIM_REFORMULATION_OFF"/>
    <ref name="MSK_SIM_REFORMULATION_FREE"/>
   </values_from>
   <default>MSK_SIM_REFORMULATION_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_SAVE_LU" val="165">
   <cmnt>Controls if the LU factorization stored should be replaced with the LU factorization
                    corresponding to the initial basis.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_INTPNT_FACTOR_METHOD" val="26">
   <cmnt>Controls the method used to factor the Newton equation system.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_RELAXS" val="85">
   <cmnt>Maximum number of relaxations allowed during the branch and bound search. A negative
                    value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
   <seealso key="MSK_DPAR_MIO_DISABLE_TERM_TIME"/>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_BASIC" val="171">
   <cmnt>If turned on, then basic and super basic constraints and variables
                    are written to the solution file independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_HEURISTIC_LEVEL" val="80">
   <cmnt>Controls the heuristic employed by the mixed-integer
                    optimizer to locate an initial good integer feasible
                    solution.  A value of zero means the heuristic is not used
                    at all. A larger value than 0 means that a gradually more
                    sophisticated heuristic is used which is computationally
                    more expensive. A negative value implies that the optimizer
                    chooses the heuristic. Normally a value around $3$ to $5$
                    should be optimal.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_KEEP_BASIS" val="82">
   <cmnt>Controls whether the integer presolve keeps bases in memory. This speeds
                    on the solution process at cost of bigger memory consumption.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SCALING" val="34">
   <cmnt>Controls how the problem is scaled
                    before the interior-point optimizer
                    is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
    <ref name="MSK_SCALING_FREE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
 </sec>
 <sec id="MSKsolstae" type="enum">
  <c name="MSK_SOL_STA_DUAL_INFEAS_CER" val="6">
   <cmnt>The solution is a certificate of dual infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_INFEAS_CER" val="5">
   <cmnt>The solution is a certificate
                    of primal infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_UNKNOWN" val="0">
   <cmnt>Status of the solution is unknown.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_OPTIMAL" val="8">
   <cmnt>The solution is nearly optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_INFEAS_CER" val="12">
   <cmnt>The solution is almost a certificate
                    of primal infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_FEAS" val="2">
   <cmnt>The solution is primal feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_INTEGER_OPTIMAL" val="15">
   <cmnt>The primal solution is near integer optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_DUAL_FEAS" val="10">
   <cmnt>The solution is nearly dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_INTEGER_OPTIMAL" val="14">
   <cmnt>The primal solution is integer optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_DUAL_INFEAS_CER" val="13">
   <cmnt>The solution is almost a certificate of dual infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_AND_DUAL_FEAS" val="11">
   <cmnt>The solution is nearly both
                    primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_OPTIMAL" val="1">
   <cmnt>The solution is optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_AND_DUAL_FEAS" val="4">
   <cmnt>The solution is both primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_NEAR_PRIM_FEAS" val="9">
   <cmnt>The solution is nearly primal feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_DUAL_FEAS" val="3">
   <cmnt>The solution is dual feasible.</cmnt>
  </c>
 </sec>
 <sec id="MSKobjsensee" type="enum">
  <c name="MSK_OBJECTIVE_SENSE_MINIMIZE" val="0">
   <cmnt>The problem should be minimized.</cmnt>
  </c>
  <c name="MSK_OBJECTIVE_SENSE_MAXIMIZE" val="1">
   <cmnt>The problem should be maximized.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoliteme" type="enum">
  <c name="MSK_SOL_ITEM_SUC" val="4">
   <cmnt>Lagrange multipliers for upper
                    bounds on the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_XC" val="0">
   <cmnt>Solution for the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_XX" val="1">
   <cmnt>Variable solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_Y" val="2">
   <cmnt>Lagrange multipliers for equations.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLX" val="5">
   <cmnt>Lagrange multipliers for lower
                    bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SUX" val="6">
   <cmnt>Lagrange multipliers for upper
                    bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SNX" val="7">
   <cmnt>Lagrange multipliers corresponding to the conic constraints on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLC" val="3">
   <cmnt>Lagrange multipliers for lower
                    bounds on the constraints.</cmnt>
  </c>
 </sec>
 <sec id="MSKboundkeye" type="enum">
  <c name="MSK_BK_FX" val="2">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_BK_LO" val="0">
   <cmnt>The constraint or variable has a finite
                    lower bound and an infinite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_FR" val="3">
   <cmnt>The constraint or variable is free.</cmnt>
  </c>
  <c name="MSK_BK_UP" val="1">
   <cmnt>The constraint or variable has an infinite
                    lower bound and an finite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_RA" val="4">
   <cmnt>The constraint or variable is ranged.</cmnt>
  </c>
 </sec>
 <sec id="MSKbasindtypee" type="constants">
  <c name="MSK_BI_ALWAYS" val="1">
   <cmnt>Basis identification is always performed even if the interior-point optimizer terminates
                    abnormally.</cmnt>
  </c>
  <c name="MSK_BI_NO_ERROR" val="2">
   <cmnt>Basis identification is performed if the interior-point optimizer terminates without an error.</cmnt>
  </c>
  <c name="MSK_BI_NEVER" val="0">
   <cmnt>Never do basis identification.</cmnt>
  </c>
  <c name="MSK_BI_IF_FEASIBLE" val="3">
   <cmnt>Basis identification is not performed if the interior-point optimizer terminates
                    with a problem status saying that the problem is primal or dual infeasible.</cmnt>
  </c>
  <c name="MSK_BI_RESERVERED" val="4">
   <cmnt>Not currently in use.</cmnt>
  </c>
 </sec>
 <sec id="MSKbranchdire" type="constants">
  <c name="MSK_BRANCH_DIR_DOWN" val="2">
   <cmnt>The mixed-integer optimizer always chooses the down branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_UP" val="1">
   <cmnt>The mixed-integer optimizer always chooses the up branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_FREE" val="0">
   <cmnt>The mixed-integer optimizer decides which branch to choose.</cmnt>
  </c>
 </sec>
 <sec id="MSKliinfiteme" type="enum">
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_ITER" val="6">
   <cmnt>Number of primal clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_INTPNT_FACTOR_NUM_NZ" val="9">
   <cmnt>Number of non-zeros in factorization.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_INTPNT_ITER" val="10">
   <cmnt>Number of interior-point iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_ITER" val="4">
   <cmnt>Number of primal-dual clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_DEG_ITER" val="3">
   <cmnt>Number of primal-dual degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER" val="2">
   <cmnt>Number of primal degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_ITER" val="1">
   <cmnt>Number of dual clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMQNZ" val="13">
   <cmnt>Number of Q non-zeros.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMANZ" val="12">
   <cmnt>Number of non-zeros in A that is read.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_PRIMAL_ITER" val="8">
   <cmnt>Number of primal pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_DUAL_ITER" val="7">
   <cmnt>Number of dual pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER" val="0">
   <cmnt>Number of dual degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_SIMPLEX_ITER" val="11">
   <cmnt>Number of simplex iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DUAL_SUB_ITER" val="5">
   <cmnt>Number of primal-dual subproblem clean iterations performed in the basis identification.</cmnt>
  </c>
 </sec>
 <sec id="MSKstreamtypee" type="enum">
  <c name="MSK_STREAM_MSG" val="1">
   <cmnt>Message stream. Log information relating to performance and progress of the optimization is written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_WRN" val="3">
   <cmnt>Warning stream. Warning messages are written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_LOG" val="0">
   <cmnt>Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_ERR" val="2">
   <cmnt>Error stream. Error messages are written to this stream.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimhotstarte" type="enum">
  <c name="MSK_SIM_HOTSTART_NONE" val="0">
   <cmnt>The simplex optimizer performs a coldstart.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_STATUS_KEYS" val="2">
   <cmnt>Only the status keys of the constraints and variables are used
                   to choose the type of hot-start.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_FREE" val="1">
   <cmnt>The simplex optimize chooses the hot-start type.</cmnt>
  </c>
 </sec>
 <sec id="MSKcallbackcodee" type="enum">
  <c name="MSK_CALLBACK_END_INTPNT" val="45">
   <cmnt>The call-back function is called
                    when the interior-point optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX_BI" val="21">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal-dual simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_PRIMAL_SIMPLEX" val="49">
   <cmnt>The call-back function is called when the primal network simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI" val="112">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \mskitem{iparam.log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_MIO" val="47">
   <cmnt>The call-back function is called when the mixed-integer optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_DUAL_SIMPLEX" val="13">
   <cmnt>The call-back function is called when the dual network simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_REPAIR" val="57">
   <cmnt>End primal feasibility repair.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_CONCURRENT" val="36">
   <cmnt>Concurrent optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_NEW_INT_MIO" val="96">
   <cmnt>The call-back function is called after a new integer solution
                    has been located by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SIMPLEX" val="90">
   <cmnt>The call-back function is called at an intermediate point in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX_NETWORK_DETECT" val="66">
   <cmnt>The call-back function is called when the network detection procedure is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_DUAL_SIMPLEX" val="48">
   <cmnt>The call-back function is called when the dual network simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_INTPNT" val="74">
   <cmnt>The call-back function is called
                    at an intermediate stage within the interior-point optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_BI" val="70">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_FULL_CONVEXITY_CHECK" val="8">
   <cmnt>Begin full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_BI" val="3">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY" val="4">
   <cmnt>Dual sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX" val="81">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_BI" val="19">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_CONCURRENT" val="1">
   <cmnt>Concurrent optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_BI" val="101">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SIMPLEX" val="72">
   <cmnt>The call-back function is called at an intermediate point in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_REPAIR" val="22">
   <cmnt>Begin primal feasibility repair.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_LICENSE_WAIT" val="11">
   <cmnt>Begin waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NETWORK_PRIMAL_SIMPLEX" val="83">
   <cmnt>The call-back function is called at an intermediate point in the primal network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NETWORK_SIMPLEX" val="50">
   <cmnt>The call-back function is called when the simplex network optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_CONIC" val="33">
   <cmnt>The call-back function is called from within the
                    conic optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_QO_REFORMULATE" val="91">
   <cmnt>The call-back function is called at an intermediate stage of the conic quadratic reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_CONIC" val="2">
   <cmnt>The call-back function is called
                    when the conic optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI" val="103">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the dual simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \mskitem{iparam.log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_OPTIMIZER" val="52">
   <cmnt>The call-back function is called when the optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRESOLVE" val="107">
   <cmnt>The call-back function is called
                    from within the presolve procedure.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX" val="93">
   <cmnt>The call-back function is called
                    from within the simplex optimizer at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF" val="99">
   <cmnt>The call-back function is called
                    from the OPF reader.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LICENSE_WAIT" val="75">
   <cmnt>MOSEK is waiting for a license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_SIMPLEX" val="15">
   <cmnt>The call-back function is called when the simplex network optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_CONIC" val="37">
   <cmnt>The call-back function is called
                    when the conic optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NETWORK_DUAL_SIMPLEX" val="104">
   <cmnt>The call-back function is called in the dual network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_QCQO_REFORMULATE" val="27">
   <cmnt>Begin QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SENSITIVITY" val="39">
   <cmnt>Dual sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI" val="61">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF_SECTION" val="100">
   <cmnt>A chunk of $Q$ non-zeos has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LU" val="76">
   <cmnt>The call-back function is called
                    from within the LU factorization procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX_BI" val="42">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_LICENSE_WAIT" val="46">
   <cmnt>End waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRESOLVE" val="86">
   <cmnt>The call-back function is called
                    from within the presolve procedure
                    at an intermediate stage.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SETUP_BI" val="5">
   <cmnt>The call-back function is called when the dual BI phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_INFEAS_ANA" val="44">
   <cmnt>The call-back function is called when the infeasibility analyzer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_INTPNT" val="95">
   <cmnt>The call-back function is called from within the
                    interior-point optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_BI" val="108">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_NONCOVEX" val="97">
   <cmnt>The call-back function is called from within the
                    nonconvex optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX_BI" val="110">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal-dual simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \mskitem{iparam.log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NONCONVEX" val="106">
   <cmnt>The call-back function is called
                    at an intermediate stage within the nonconvex optimizer where
                    the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_BI" val="38">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_READ" val="63">
   <cmnt>MOSEK has finished reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI" val="26">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX_NETWORK_DETECT" val="31">
   <cmnt>The call-back function is called when the network detection procedure is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_DUAL_SIMPLEX" val="88">
   <cmnt>The call-back function is called at an intermediate point in the primal-dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX" val="111">
   <cmnt>The call-back function is called  in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_DUAL_SIMPLEX" val="34">
   <cmnt>The call-back function is called
                    from within the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_FULL_CONVEXITY_CHECK" val="73">
   <cmnt>The call-back function is called at an intermediate stage of the full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_PRIMAL_SIMPLEX" val="98">
   <cmnt>The call-back function is called
                    from within the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NONCONVEX" val="16">
   <cmnt>The call-back function is called
                    when the nonconvex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX_BI" val="94">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the simplex clean-up phase.
                    The frequency of the call-backs is controlled by the
                    \mskitem{iparam.log_sim_freq} parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX" val="6">
   <cmnt>The call-back function is called when the dual simplex optimizer started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX" val="25">
   <cmnt>The call-back function is called when the primal simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_NONCONVEX" val="51">
   <cmnt>The call-back function is called
                    when the nonconvex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI" val="24">
   <cmnt>The call-back function is called when the primal BI setup is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_READ" val="92">
   <cmnt>Intermediate stage in reading.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_OPTIMIZER" val="17">
   <cmnt>The call-back function is called when the optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_READ" val="28">
   <cmnt>MOSEK has started reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NONCONVEX" val="84">
   <cmnt>The call-back function is called
                    at an intermediate stage within the nonconvex optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX" val="60">
   <cmnt>The call-back function is called when the primal simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_DUAL_SIMPLEX_BI" val="56">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal-dual clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_BI" val="68">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_NETWORK_DUAL_SIMPLEX" val="82">
   <cmnt>The call-back function is called at an intermediate point in the dual network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SETUP_BI" val="40">
   <cmnt>The call-back function is called when the dual BI phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_BI" val="35">
   <cmnt>The call-back function is called
                    when the basis identification procedure
                    is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SETUP_BI" val="59">
   <cmnt>The call-back function is called when the primal BI setup is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_WRITE" val="32">
   <cmnt>MOSEK has started writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX_BI" val="65">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the simplex clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SENSITIVITY" val="58">
   <cmnt>Primal sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX" val="29">
   <cmnt>The call-back function is called when the simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRESOLVE" val="53">
   <cmnt>The call-back function is called
                    when the presolve is completed.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INFEAS_ANA" val="9">
   <cmnt>The call-back function is called when the infeasibility analyzer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX" val="20">
   <cmnt>The call-back function is called when the primal-dual simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY" val="23">
   <cmnt>Primal sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI" val="7">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the dual simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_QCQO_REFORMULATE" val="62">
   <cmnt>End QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SENSIVITY" val="89">
   <cmnt>The call-back function is called at an intermediate stage of the primal sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_WRITE" val="67">
   <cmnt>MOSEK has finished writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX" val="41">
   <cmnt>The call-back function is called when the dual simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX" val="109">
   <cmnt>The call-back function is called  in the primal-dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX_BI" val="30">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INTPNT" val="10">
   <cmnt>The call-back function is called
                    when the interior-point optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SENSIVITY" val="71">
   <cmnt>The call-back function is called at an intermediate stage of the dual sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX" val="64">
   <cmnt>The call-back function is called when the simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_BI" val="54">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    when the primal phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO" val="77">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX" val="102">
   <cmnt>The call-back function is called in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_INTPNT" val="79">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_DUAL_SIMPLEX" val="55">
   <cmnt>The call-back function is called when the primal-dual simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_CONIC" val="69">
   <cmnt>The call-back function is called
                    at an intermediate stage within the conic optimizer where
                    the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_PRESOLVE" val="80">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    presolve.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_BI" val="0">
   <cmnt>The basis identification procedure
                    has been started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX" val="78">
   <cmnt>The call-back function is called at an intermediate point in the mixed-integer optimizer while running the
                    dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_WRITE_OPF" val="113">
   <cmnt>The call-back function is called
                    from the OPF writer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_NETWORK_PRIMAL_SIMPLEX" val="105">
   <cmnt>The call-back function is called in the primal network simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_FULL_CONVEXITY_CHECK" val="43">
   <cmnt>End full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_ORDER" val="85">
   <cmnt>The call-back function is called
                    from within the matrix ordering procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_BI" val="87">
   <cmnt>The call-back function is called
                    from within the basis identification procedure
                    at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRESOLVE" val="18">
   <cmnt>The call-back function is called
                    when the presolve is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_MIO" val="12">
   <cmnt>The call-back function is called when the mixed-integer optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_NETWORK_PRIMAL_SIMPLEX" val="14">
   <cmnt>The call-back function is called when the primal network simplex optimizer is started.</cmnt>
  </c>
 </sec>
 <sec id="MSKsymmattypee" type="enum">
  <c name="MSK_SYMMAT_TYPE_SPARSE" val="0">
   <cmnt>Sparse symmetric matrix.</cmnt>
  </c>
 </sec>
 <sec id="MSKfeaturee" type="enum">
  <c name="MSK_FEATURE_PTOM" val="2">
   <cmnt>Mixed-integer extension.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTON" val="1">
   <cmnt>Nonlinear extension.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTS" val="0">
   <cmnt>Base system.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTOX" val="3">
   <cmnt>Non-convex extension.</cmnt>
  </c>
 </sec>
 <sec id="MSKmarke" type="enum">
  <c name="MSK_MARK_LO" val="0">
   <cmnt>The lower bound is selected for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_MARK_UP" val="1">
   <cmnt>The upper bound is selected for sensitivity analysis.</cmnt>
  </c>
 </sec>
 <sec id="MSKconetypee" type="enum">
  <c name="MSK_CT_QUAD" val="0">
   <cmnt>The cone is a quadratic cone.</cmnt>
  </c>
  <c name="MSK_CT_RQUAD" val="1">
   <cmnt>The cone is a rotated quadratic cone.</cmnt>
  </c>
 </sec>
 <sec id="MSKfeasrepairtypee" type="constants">
  <c name="MSK_FEASREPAIR_OPTIMIZE_NONE" val="0">
   <cmnt>Do not optimize the feasibility repair problem.</cmnt>
  </c>
  <c name="MSK_FEASREPAIR_OPTIMIZE_COMBINED" val="2">
   <cmnt>Minimize with original objective subject to minimal weighted violation of bounds.</cmnt>
  </c>
  <c name="MSK_FEASREPAIR_OPTIMIZE_PENALTY" val="1">
   <cmnt>Minimize weighted sum of violations.</cmnt>
  </c>
 </sec>
 <sec id="MSKiomodee" type="constants">
  <c name="MSK_IOMODE_READ" val="0">
   <cmnt>The file is read-only.</cmnt>
  </c>
  <c name="MSK_IOMODE_WRITE" val="1">
   <cmnt>The file is write-only. If the file exists then it is
                    truncated when it is opened. Otherwise it is created when it is opened.</cmnt>
  </c>
  <c name="MSK_IOMODE_READWRITE" val="2">
   <cmnt>The file is to read and written.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimseltypee" type="constants">
  <c name="MSK_SIM_SELECTION_FULL" val="1">
   <cmnt>The optimizer uses full pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_PARTIAL" val="5">
   <cmnt>The optimizer uses a partial selection approach. The approach is usually
                    beneficial if the number of variables is much larger than  the number of constraints.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_FREE" val="0">
   <cmnt>The optimizer chooses the pricing strategy.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_ASE" val="2">
   <cmnt>The optimizer uses approximate steepest-edge
                    pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_DEVEX" val="3">
   <cmnt>The optimizer uses devex steepest-edge pricing (or if it is not available an
                    approximate steep-edge selection).</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_SE" val="4">
   <cmnt>The optimizer uses steepest-edge selection (or if it is not available an
                    approximate steep-edge selection).</cmnt>
  </c>
 </sec>
 <sec id="MSKmsgkeye" type="enum">
  <c name="MSK_MSG_READING_FILE" val="1000">
   <cmnt></cmnt>
  </c>
  <c name="MSK_MSG_WRITING_FILE" val="1001">
   <cmnt></cmnt>
  </c>
  <c name="MSK_MSG_MPS_SELECTED" val="1100">
   <cmnt></cmnt>
  </c>
 </sec>
 <sec id="MSKmiomodee" type="constants">
  <c name="MSK_MIO_MODE_IGNORED" val="0">
   <cmnt>The integer constraints are ignored and the problem is solved as a continuous problem.</cmnt>
  </c>
  <c name="MSK_MIO_MODE_LAZY" val="2">
   <cmnt>Integer restrictions should be satisfied if
                    an optimizer is available for the problem.</cmnt>
  </c>
  <c name="MSK_MIO_MODE_SATISFIED" val="1">
   <cmnt>Integer restrictions should be satisfied.</cmnt>
  </c>
 </sec>
 <sec id="MSKdinfiteme" type="enum">
  <c name="MSK_DINF_SOL_ITG_PVIOLCONES" val="57">
   <cmnt>Maximal primal violation for primal conic constraints in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_PRIMAL_FEAS" val="13">
   <cmnt>Primal feasibility measure reported by the
                    interior-point optimizers. (For the
                    interior-point optimizer this measure does not
                    directly related to the original problem because
                    a homogeneous model is employed).</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLBARVAR" val="61">
   <cmnt>Maximal dual bound violation for $\bar{X}$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CMIR_SEPERATION_TIME" val="17">
   <cmnt>Seperation time for CMIR cuts.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DVIOLVAR" val="50">
   <cmnt>Maximal dual bound violation for $x^x$ in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_ELI_TIME" val="33">
   <cmnt>Total time spent in the eliminator
                    since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OPTIMIZER_TIME" val="25">
   <cmnt>Time spent in the optimizer while solving the relaxtions.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_FACTOR_NUM_FLOPS" val="10">
   <cmnt>An estimate of the number of flops used in the factorization.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_TIME" val="30">
   <cmnt>Time spent in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_BI_DUAL_TIME" val="4">
   <cmnt>Time spent within the dual phase basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLCON" val="67">
   <cmnt>Maximal primal bound violation for $x^c$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_TIME" val="43">
   <cmnt>Time spent in the network simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_TIME" val="35">
   <cmnt>Total time (in seconds) spent in the presolve
                    since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_LINDEP_TIME" val="34">
   <cmnt>Total time spent  in the linear dependency checker
                    since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_DUAL_TIME" val="39">
   <cmnt>Time spent in the dual simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_PROBING_TIME" val="26">
   <cmnt>Total time for probing.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_CUTGEN_TIME" val="27">
   <cmnt>Total time for cut generation.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_OBJ" val="44">
   <cmnt>Objective value reported by the
                    simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_REL_GAP" val="24">
   <cmnt>Given that the mixed-integer optimizer has computed a feasible solution and a bound
                    on the optimal objective value, then this item contains the relative gap defined by
                    \[
\frac{| \mbox{(objective value of feasible solution)}-\mbox{(objective bound)} | }{\max(\delta,|\mbox{(objective value of feasible solution)}|)}.
\]
%
where $\delta$ is given by the paramater \mskitem{dparam.mio_rel_gap_const}. Otherwise it has the value -1.0.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PRIMAL_OBJ" val="51">
   <cmnt>Primal objective value of the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_HEURISTIC_TIME" val="20">
   <cmnt>Time spent in the optimizer while solving the relaxtions.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CG_SEPERATION_TIME" val="16">
   <cmnt>Seperation time for CG cuts.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLBARVAR" val="55">
   <cmnt>Maximal primal bound violation for $\bar{X}$ in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_OPTIMIZER_TIME" val="32">
   <cmnt>Total time spent in the optimizer since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_PRESOLVE_TIME" val="29">
   <cmnt>Time spent in while presolveing the root relaxation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLCON" val="56">
   <cmnt>Maximal primal bound violation for $x^c$ in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_OBJ" val="9">
   <cmnt>Dual objective value reported by the
                    interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_TIME" val="15">
   <cmnt>Time spent within the interior-point optimizer
                    since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ" val="18">
   <cmnt>If \mosek{} has successfully constructed an integer feasible solution, then this item
                    contains the optimal objective value corresponding to the feasible solution.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_FEAS" val="40">
   <cmnt>Feasibility measure reported by the
                    simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_PRIMAL_TIME" val="46">
   <cmnt>Time spent in the primal simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_TIME" val="47">
   <cmnt>Time spent in the simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_PRIMAL_TIME" val="42">
   <cmnt>Time spent in the primal network simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE" val="19">
   <cmnt>Value of the dual bound after presolve but before cut generation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_TIME" val="3">
   <cmnt>Time spent within the clean-up phase of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_TIME" val="37">
   <cmnt>Time spent with conic quadratic reformulation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DUAL_OBJ" val="60">
   <cmnt>Dual objective value of the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLCONES" val="68">
   <cmnt>Maximal primal violation for primal conic constraints in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_FEAS" val="8">
   <cmnt>Dual feasibility measure reported by the
                    interior-point optimizer. (For the
                    interior-point optimizer this measure does not
                    directly related to the original problem because
                    a homogeneous model is employed.)</cmnt>
  </c>
  <c name="MSK_DINF_CONCURRENT_TIME" val="7">
   <cmnt>Time spent within the concurrent optimizer since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLBARVAR" val="66">
   <cmnt>Maximal primal bound violation for $\bar{X}$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_RD_TIME" val="38">
   <cmnt>Time spent reading the data file.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DVIOLCON" val="49">
   <cmnt>Maximal dual bound violation for $x^c$ in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PRIMAL_OBJ" val="65">
   <cmnt>Primal objective value of the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLVAR" val="69">
   <cmnt>Maximal primal bound violation for $x^x$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLCON" val="62">
   <cmnt>Maximal dual bound violation for $x^c$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_NETWORK_DUAL_TIME" val="41">
   <cmnt>Time spent in the dual network simplex
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PRIMAL_OBJ" val="54">
   <cmnt>Primal objective value of the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_INT" val="23">
   <cmnt>The primal objective value corresponding to the best integer feasible
                    solution. Please note that at least one integer feasible solution must have located i.e.
                    check \mskitem{iinfitem.mio_num_int_solutions}.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_USER_OBJ_CUT" val="31">
   <cmnt>If the objective cut is used, then this information item has the value of the cut.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLITG" val="58">
   <cmnt>Maximal  violation for the integer constraints in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_OPT_STATUS" val="11">
   <cmnt>This measure should converge to +1 if the problem
                    has a primal-dual optimal solution, and converge to -1 
                    if problem is (strictly) primal or dual infeasible. Furthermore, if the measure converges to 0
                    the problem is usually ill-posed.</cmnt>
  </c>
  <c name="MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ" val="36">
   <cmnt>The optimal objective value of the penalty function.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_BOUND" val="22">
   <cmnt>The best known bound on the objective function. This value
                    is undefined until at least one relaxation has been solved:
                    To see if this is the case check that
                    \mskitem{iinfitem.mio_num_relax} is stricly
                    positive.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_DUAL_TIME" val="0">
   <cmnt>Time  spent within the dual clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_TIME" val="6">
   <cmnt>Time spent within the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DUAL_OBJ" val="48">
   <cmnt>Dual objective value of the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_PRIMAL_DUAL_TIME" val="1">
   <cmnt>Time spent within the primal-dual clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLVAR" val="59">
   <cmnt>Maximal primal bound violation for $x^x$ in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_PRIMAL_OBJ" val="14">
   <cmnt>Primal objective value reported by the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_ORDER_TIME" val="12">
   <cmnt>Order time (in seconds).</cmnt>
  </c>
  <c name="MSK_DINF_BI_PRIMAL_TIME" val="5">
   <cmnt>Time  spent within the primal phase of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PVIOLCON" val="52">
   <cmnt>Maximal primal bound violation for $x^c$ in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_ABS_GAP" val="21">
   <cmnt>Given the mixed-integer optimizer has computed a feasible solution and a bound
                    on the optimal objective value, then this item contains the absolute gap defined by
                    \[
|\mbox{(objective value of feasible solution)}-\mbox{(objective bound)}|.
\]
%
Otherwise it has the value -1.0.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLVAR" val="64">
   <cmnt>Maximal dual bound violation for $x^x$ in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLCONES" val="63">
   <cmnt>Maximal dual violation for dual conic constraints in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PVIOLVAR" val="53">
   <cmnt>Maximal primal bound violation for $x^x$ in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_PRIMAL_DUAL_TIME" val="45">
   <cmnt>Time spent in the primal-dual simplex optimizer
                    optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_PRIMAL_TIME" val="2">
   <cmnt>Time spent within the primal clean-up optimizer of the basis identification
                    procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_OPTIMIZER_TIME" val="28">
   <cmnt>Time spent in the optimizer while solving the root relaxation.</cmnt>
  </c>
 </sec>
 <sec id="MSKparametertypee" type="enum">
  <c name="MSK_PAR_INVALID_TYPE" val="0">
   <cmnt>Not a valid parameter.</cmnt>
  </c>
  <c name="MSK_PAR_STR_TYPE" val="3">
   <cmnt>Is a string parameter.</cmnt>
  </c>
  <c name="MSK_PAR_DOU_TYPE" val="1">
   <cmnt>Is a double parameter.</cmnt>
  </c>
  <c name="MSK_PAR_INT_TYPE" val="2">
   <cmnt>Is an integer parameter.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodetypee" type="enum">
  <c name="MSK_RESPONSE_WRN" val="1">
   <cmnt>The response code is a warning.</cmnt>
  </c>
  <c name="MSK_RESPONSE_TRM" val="2">
   <cmnt>The response code is an optimizer termination status.</cmnt>
  </c>
  <c name="MSK_RESPONSE_UNK" val="4">
   <cmnt>The response code does not belong to any class.</cmnt>
  </c>
  <c name="MSK_RESPONSE_OK" val="0">
   <cmnt>The response code is OK.</cmnt>
  </c>
  <c name="MSK_RESPONSE_ERR" val="3">
   <cmnt>The response code is an error.</cmnt>
  </c>
 </sec>
 <sec id="MSKprostae" type="enum">
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_INFEAS" val="6">
   <cmnt>The problem is primal and dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS" val="4">
   <cmnt>The problem is primal infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_ILL_POSED" val="7">
   <cmnt>The problem is ill-posed. For example,
                    it may be primal and dual feasible but
                    have a positive duality gap.</cmnt>
  </c>
  <c name="MSK_PRO_STA_UNKNOWN" val="0">
   <cmnt>Unknown problem status.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_FEAS" val="2">
   <cmnt>The problem is primal feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_PRIM_AND_DUAL_FEAS" val="8">
   <cmnt>The problem is at least nearly primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_DUAL_FEAS" val="10">
   <cmnt>The problem is at least nearly dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED" val="11">
   <cmnt>The problem is either primal infeasible or unbounded. This may occur for
                    mixed-integer problems.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_FEAS" val="1">
   <cmnt>The problem is primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_INFEAS" val="5">
   <cmnt>The problem is dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_NEAR_PRIM_FEAS" val="9">
   <cmnt>The problem is at least nearly primal feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_FEAS" val="3">
   <cmnt>The problem is dual feasible.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingtypee" type="constants">
  <c name="MSK_SCALING_NONE" val="1">
   <cmnt>No scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_MODERATE" val="2">
   <cmnt>A conservative scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_AGGRESSIVE" val="3">
   <cmnt>A very aggressive scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_FREE" val="0">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodee" type="enum">
  <c name="MSK_RES_ERR_PARAM_TYPE" val="1218">
   <cmnt>The parameter type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKX" val="1268">
   <cmnt>Invalid value in \comp{skx}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MUL_A_ELEMENT" val="1254">
   <cmnt>An element in $A$ is defined multiple times.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE" val="1170">
   <cmnt>An invalid name occurred in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_NETWORK_PROBLEM" val="1504">
   <cmnt>The problem is not a network problem as expected. The error occurs if a network optimizer is applied to a problem that cannot (easily) be converted to a network problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QSEC" val="1113">
   <cmnt>Multiple \comp{QSECTION}s are specified
              for a constraint in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_INVALID" val="3055">
   <cmnt>Invalid range given in the sensitivity file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKN" val="1274">
   <cmnt>Invalid value in \comp{skn}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKC" val="1267">
   <cmnt>Invalid value in \comp{skc}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_LARGE" val="1204">
   <cmnt>An index in an argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_BCOORD" val="7115">
   <cmnt>Duplicate index in BCOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX" val="1700">
   <cmnt>An optimization problem cannot be relaxed.
              This is the case e.g. for general nonlinear optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE_STR" val="1271">
   <cmnt>Invalid cone type string encountered.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_FEATURE_EXPIRE" val="505">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_COMPRESSION" val="1800">
   <cmnt>Invalid compression type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_ROW" val="705">
   <cmnt>One or more (near) zero elements are specified in a sparse row of a matrix.
              It is redundant to specify zero elements. Hence it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_CON" val="351">
   <cmnt>One or more lines in the constraint section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_INT" val="7110">
   <cmnt>Duplicate INT keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARG_IS_TOO_LARGE" val="1227">
   <cmnt>The value of a argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_SINGULAR_MATRIX" val="7000">
   <cmnt>A matrix is singular.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_FUNC" val="1432">
   <cmnt>The user-defined nonlinear function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZERO_AIJ" val="63">
   <cmnt>One or more zero elements are specified in A.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_UNKNOWN" val="7001">
   <cmnt>An unknown error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_CONIC_PROBLEM" val="1163">
   <cmnt>The problem contains cones that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UPPER_BOUND_IS_A_NAN" val="1391">
   <cmnt>The upper bound specificied is not a number (nan).</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_DUPLICATE" val="3944">
   <cmnt>A value in a symmetric matric as been specified more than once.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL" val="1221">
   <cmnt>An index in an array argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MAX" val="1016">
   <cmnt>Maximum number of licenses is reached.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES" val="850">
   <cmnt>Two constraint names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FORMAT_TYPE" val="1283">
   <cmnt>Invalid format type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_PRIMAL_INFEAS_CER" val="2000">
   <cmnt>A certificate of primal infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_MANY_CONCURRENT_TASKS" val="3090">
   <cmnt>Too many concurrent tasks specified.</cmnt>
  </c>
  <c name="MSK_RES_TRM_STALL" val="10006">
   <cmnt>The optimizer is terminated due to slow progress.

              Stalling means that numerical problems prevent the optimizer from
              making reasonable progress and that it make no sense to continue.
              In many cases this happens if the problem is badly scaled or
              otherwise ill-conditioned. There is no guarantee that the
              solution will be (near) feasible or near optimal. However, often
              stalling happens near the optimum, and the returned solution may
              be of good quality. Therefore, it is recommended to check the
              status of then solution. If the solution near optimal the solution is
              most likely good enough for most practical purposes.

              Please note that if a linear optimization problem is solved using
              the interior-point optimizer with basis identification turned on,
              the returned basic solution likely to have high accuracy, even though
              the optimizer stalled.

              Some common causes of stalling are a) badly scaled models, b)
              near feasible or near infeasible problems and c) a non-convex
              problems. Case c) is only relevant for general non-linear
              problems. It is not possible in general for \mosek to check if a
              specific problems is convex since such a check would be NP hard
              in itself.  This implies that care should be taken when solving
              problems involving general user defined functions.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_PREMATURE_EOF" val="1172">
   <cmnt>Premature end of file in an OPF file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LIVING_TASKS" val="1066">
   <cmnt>All tasks associated with an enviroment must be deleted
              before the environment is deleted. There are still some undeleted tasks.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCONE" val="1304">
   <cmnt>The value specified for \comp{maxnumcone} is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMVARLIM" val="1251">
   <cmnt>Maximum number of variables limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_WRN_USING_GENERIC_NAMES" val="503">
   <cmnt>Generic names are used because a name is not valid. For instance when writing an LP file the names must not contain blanks or start with a digit.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REPAIR_INVALID_PROBLEM" val="1710">
   <cmnt>The feasibility repair does not support the specified problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_VALUE_STR" val="1217">
   <cmnt>The parameter value string is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QOBJ_UPPER_TRIANGLE" val="1415">
   <cmnt>An element in the upper triangle of $Q^o$ is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LOWER_BOUND_IS_A_NAN" val="1390">
   <cmnt>The lower bound specificied is not a number (nan).</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_POINTER" val="1065">
   <cmnt>An argument to a function is unexpectedly a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_STR" val="1208">
   <cmnt>The parameter name is not correct for a string parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_SMALL" val="1216">
   <cmnt>The parameter value is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLVER_PROBTYPE" val="1259">
   <cmnt>Problem type does not match the chosen optimizer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_INDEX" val="1220">
   <cmnt>An integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL_HESSUBI" val="1440">
   <cmnt>The user-defined nonlinear function reported an invalid subscript in the Hessian.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL_HESSUBJ" val="1441">
   <cmnt>The user-defined nonlinear function reported an invalid subscript in the Hessian.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPEN_DL" val="1030">
   <cmnt>A dynamic link library could not be opened.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAST" val="1262">
   <cmnt>Invalid index \comp{last}. A given index was out of expected range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_EMPTY" val="1151">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER_VERSION" val="1026">
   <cmnt>The version specified in the checkout request is greater than the highest version number the daemon supports.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_INIT" val="1045">
   <cmnt>Could not initialize a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NAME_ITEM" val="1280">
   <cmnt>An invalid name item code is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS" val="7103">
   <cmnt>Too many constraints specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_LO_BOUND" val="52">
   <cmnt>A numerically large lower bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_UP" val="3053">
   <cmnt>Analysis of upper bound requested for an index, where no upper bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT" val="1121">
   <cmnt>Duplicate elements is specfied in a $Q$ matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES" val="4502">
   <cmnt>Two barvariable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE" val="1305">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_VAR_TYPE" val="7111">
   <cmnt>Invalid variable type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS" val="904">
   <cmnt>This warning is issued by the problem analyzer if a
              constraint is bound nearly integral.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_INVALID_SOL_ITG" val="807">
   <cmnt>The intial value for one or more  of the integer variables is not feasible.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_TASK" val="1061">
   <cmnt>\comp{task} is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_EXPIRE" val="500">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE" val="1051">
   <cmnt>Out of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_ENV" val="1060">
   <cmnt>\comp{env} is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMCONLIM" val="1250">
   <cmnt>Maximum number of constraints limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED" val="1711">
   <cmnt>Computation the optimal relaxation failed. The cause may have been numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS" val="6010">
   <cmnt>Unhandled solution status.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_UNSUPPORTED" val="7122">
   <cmnt>Unsupported feature is present.</cmnt>
  </c>
  <c name="MSK_RES_WRN_OPEN_PARAM_FILE" val="50">
   <cmnt>The parameter file could not be opened.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_VAR_NAME" val="1077">
   <cmnt>An invalid variable name is used.</cmnt>
  </c>
  <c name="MSK_RES_OK" val="0">
   <cmnt>No error occurred.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_SOLUTION_STATUS" val="3057">
   <cmnt>No optimal solution found to the original problem given for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_CON" val="1010">
   <cmnt>The problem has too many constraints to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_FORMAT" val="1090">
   <cmnt>The specified format cannot be read.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CJ" val="57">
   <cmnt>A numerically large value is specified for one $c_{j}$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED" val="7105">
   <cmnt>No version specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_EXPIRED" val="1001">
   <cmnt>The license has expired.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_DIMENSION" val="1201">
   <cmnt>A function argument is of incorrect dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLC" val="1461">
   <cmnt>$l^c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLX" val="1471">
   <cmnt>$l^x$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX" val="3940">
   <cmnt>A row index specified for sparse symmetric maxtrix is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NON_UNIQUE_ARRAY" val="5000">
   <cmnt>An array does not contain unique elements.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT" val="4000">
   <cmnt>The file format does not support a problem with symmetric matrix variables.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CON_NAME" val="1112">
   <cmnt>A constraint name was specified multiple times in the \comp{ROWS} section.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER" val="1015">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_FEW_BASIS_VARS" val="400">
   <cmnt>An incomplete basis has been specified. Too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_BOUND_KEY" val="1108">
   <cmnt>An invalid bound key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_CREATE" val="1048">
   <cmnt>Could not create a thread. This error may occur if a large
              number of environments are created and not deleted again.
              In any case it is a good practice to minimize the number of
              environments created.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_MAX_NUM" val="1247">
   <cmnt>A specified index is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_IOMODE" val="1801">
   <cmnt>Invalid io mode.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_ARRAY_TOO_SMALL" val="3001">
   <cmnt>An input array was too short.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_AIJ" val="1473">
   <cmnt>$a_{i,j}$ contains an invalid floating point value, i.e. a \texttt{NaN} or an infinite value.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_SIZE" val="1301">
   <cmnt>A cone with too few members is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_FUNC_RET" val="1430">
   <cmnt>An user function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_TYPE" val="1117">
   <cmnt>Invalid cone type specified in a \comp{CSECTION}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_LARGE" val="1215">
   <cmnt>The parameter value is too large.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PRESOLVE_OUTOFSPACE" val="802">
   <cmnt>The presolve is incomplete due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_INTVAR" val="1012">
   <cmnt>The problem contains too many integer variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE" val="1552">
   <cmnt>No optimizer is available for this class of optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_VARIABLES" val="7117">
   <cmnt>Too few variables defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM" val="1503">
   <cmnt>The global optimizer can only be applied to problems without semidefinite variables.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_NO_OPTIMIZER" val="1551">
   <cmnt>No optimizer is available for the current class of integer optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANS" val="7008">
   <cmnt>Invalid argument trans.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_PERM_ARRAY" val="1299">
   <cmnt>An invalid permutation array is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES" val="4005">
   <cmnt>The file format does not support a problem with conic constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_PSD" val="1295">
   <cmnt>The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.
              The parameter \mskitem{dparam.check_convexity_rel_tol} can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL" val="3000">
   <cmnt>An internal error occurred. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_VAR_NAME" val="1154">
   <cmnt>A variable name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INCOMPATIBLE" val="1150">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK" val="2500">
   <cmnt>The required solution is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_INDEX" val="1225">
   <cmnt>A long integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_MANY_BASIS_VARS" val="405">
   <cmnt>A basis with too many variables has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_NO_INFO" val="1081">
   <cmnt>No available information about the space usage.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NZ_IN_UPR_TRI" val="200">
   <cmnt>Non-zero elements specified in the upper triangle of a matrix were ignored.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBI" val="1405">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_CON_TYPE" val="7112">
   <cmnt>Invalid constraint type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBK" val="1404">
   <cmnt>Invalid value in \comp{qcsubk}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBJ" val="1406">
   <cmnt>Invalid value in \comp{qcsubj}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_TYPE" val="1198">
   <cmnt>Incorrect argument type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_END_OF_FILE" val="1059">
   <cmnt>End of file reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_EQUALITY" val="1290">
   <cmnt>The model contains a nonlinear equality which defines a nonconvex set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NR_ARGUMENTS" val="1199">
   <cmnt>Incorrect number of function arguments.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_PSD" val="1293">
   <cmnt>The quadratic constraint matrix is not positive semidefinite as expected for a constraint with finite upper bound. This results in a nonconvex problem.
              The parameter \mskitem{dparam.check_convexity_rel_tol} can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_CONE_NAME" val="1078">
   <cmnt>An invalid cone name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_CON_NAME" val="1076">
   <cmnt>An invalid constraint name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_RANGED" val="1292">
   <cmnt>The model contains a nonlinear ranged constraint which by definition defines a nonconvex set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME" val="1156">
   <cmnt>Empty variable names cannot be written to OPF files.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_FORMAT" val="3050">
   <cmnt>Syntax error in sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONCONVEX" val="1291">
   <cmnt>The optimization problem is nonconvex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNB_STEP_SIZE" val="3100">
   <cmnt>A step size in an optimizer was unexpectedly unbounded. For
              instance, if the step-size becomes unbounded in phase 1 of
              the simplex algorithm then an error occurs.  Normally this
              will happen only if the problem is badly formulated. Please
              contact \mosek{} support if this error occurs.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_VAR_NAME" val="1106">
   <cmnt>An undefined variable name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_NAME" val="1056">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_WRITE" val="1054">
   <cmnt>File write error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MBT_INCOMPATIBLE" val="2550">
   <cmnt>The MBT file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CANNOT_HANDLE_NL" val="2506">
   <cmnt>A function cannot handle a task with nonlinear function call-backs.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BASIS_SOL" val="1600">
   <cmnt>No basic solution is defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ORD_INVALID" val="1131">
   <cmnt>Invalid content in branch ordering file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_CB_CONNECT" val="3002">
   <cmnt>Failed to connect a callback object.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_NSD" val="1296">
   <cmnt>The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem.
              The parameter \mskitem{dparam.check_convexity_rel_tol} can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NON_SYMMETRIC_Q" val="1120">
   <cmnt>A non symmetric matrice has been speciefied.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNKNOWN" val="1050">
   <cmnt>Unknown error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_TYPE" val="1232">
   <cmnt>The information type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LINK_FILE_DLL" val="1040">
   <cmnt>A file cannot be linked to a stream in the DLL version.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES" val="851">
   <cmnt>Two variable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_DOU" val="1206">
   <cmnt>The parameter name is not correct for a double parameter.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES" val="852">
   <cmnt>Two barvariable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BARS_FOR_SOLUTION" val="3916">
   <cmnt>There is no $\bar{s}$ available for the solution specified. In particular note there are no $\bar{s}$ defined for the basic and integer solutions.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_LOCK" val="1046">
   <cmnt>Could not lock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_FUNCTIONS_NOT_ALLOWED" val="1428">
   <cmnt>An operation that is invalid for problems with nonlinear functions defined has been attempted.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FREE_CONSTRAINT" val="1155">
   <cmnt>Free constraints cannot be written in LP file format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_INVALID_HOSTID" val="1025">
   <cmnt>The host ID specified in the license file does not match the host ID of the computer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE" val="1272">
   <cmnt>Invalid cone type code is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_NAME" val="1231">
   <cmnt>An integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_OBJ" val="7107">
   <cmnt>Duplicate OBJ keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_INTERNAL" val="3999">
   <cmnt>An internal fatal error occurred in an interface function.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_RANGE" val="3052">
   <cmnt>Index out of range in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_INT_INDEX" val="7121">
   <cmnt>Invalid INT index.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_DOU" val="510">
   <cmnt>The parameter name is not recognized as a double parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBI" val="1401">
   <cmnt>Invalid value in \comp{qosubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBJ" val="1402">
   <cmnt>Invalid value in \comp{qosubj}.</cmnt>
  </c>
  <c name="MSK_RES_TRM_USER_CALLBACK" val="10007">
   <cmnt>The optimizer terminated due to the return of
              the user-defined call-back function.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_LENNEQ" val="1197">
   <cmnt>Incorrect length of arguments.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IN_ARGUMENT" val="1200">
   <cmnt>A function argument is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMVAR" val="1241">
   <cmnt>The maximum number of variables specified is smaller than the number of
              variables in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_FIELD" val="1101">
   <cmnt>A field in the MPS file is invalid. Probably it is too wide.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_OPERAND" val="3104">
   <cmnt>The code list data was invalid. An unknown operand was used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_FORMAT" val="1168">
   <cmnt>Syntax error in an OPF file</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_LARGE_BOUNDS" val="900">
   <cmnt>This warning is issued by the problem analyzer, if one or more constraint or variable bounds are very large.
              One should consider omitting these bounds entirely by setting them to +inf or -inf.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CANNOT_CLONE_NL" val="2505">
   <cmnt>A task with a nonlinear function call-back cannot be cloned.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR" val="3942">
   <cmnt>Only the lower triangular part of sparse symmetric matrix should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CSEC" val="1116">
   <cmnt>Multiple \comp{CSECTION}s are given the same name.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_FUNC_RET_DATA" val="1431">
   <cmnt>An user function returned invalid data.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONIC_PROBLEM" val="1502">
   <cmnt>The conic optimizer can only be applied to problems with linear objective and constraints. Many problems such convex quadratically constrained problems can easily be reformulated to conic problems. See the appropriate \mosek{} manual for details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_APTRE" val="1253">
   <cmnt>\comp{aptre[j]} is strictly smaller than \comp{aptrb[j]} for some \comp{j}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_FACTOR" val="1610">
   <cmnt>The factorization of the basis is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_WCHAR" val="2901">
   <cmnt>An invalid \comp{wchar} string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_PARSE" val="7100">
   <cmnt>An error occurred while parsing an CBF file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_RQUAD_CONES_WITH_ROOT_FIXED_AT_ZERO" val="931">
   <cmnt>For at least one rotated quadratic cone at least one of the root variables are fixed at (nearly) zero. This may cause problems such as a very large dual solution.
              Therefore, it is recommended to remove such cones before optimizing the problems, or to fix all the variables in the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE" val="1005">
   <cmnt>The problem is bigger than the license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_C" val="1470">
   <cmnt>$c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_CON_NAME" val="1171">
   <cmnt>A constraint name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER" val="7130">
   <cmnt>An invalid root optimizer was selected for the problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_AIJ" val="1380">
   <cmnt>A numerically huge value is specified for an
              $a_{i,j}$ element in $A$.  The parameter
              \mskitem{dparam.data_tol_aij_huge} controls
              when an $a_{i,j}$ is considered huge.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS" val="7118">
   <cmnt>Too few constraints defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_MISSING_OPERAND" val="3105">
   <cmnt>The code list data was invalid. Missing operand for operator.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_CONE_NAMES" val="4503">
   <cmnt>Two cone names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MBT_INVALID" val="2551">
   <cmnt>The MBT file is invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_NO_SOL_ITG" val="810">
   <cmnt>The construct solution requires an integer solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJECTIVE_RANGE" val="1260">
   <cmnt>Empty objective range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD3" val="1126">
   <cmnt>A tab char occurred in field 3.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_NAME" val="1230">
   <cmnt>A double information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_APPEND" val="1264">
   <cmnt>Cannot append a negative number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK" val="1270">
   <cmnt>Invalid status key code.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_INT" val="1207">
   <cmnt>The parameter name is not correct for an integer parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS" val="1266">
   <cmnt>An invalid basis is specified. Either
              too many or too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMBARVAR" val="1242">
   <cmnt>The maximum number of semidefinite variables specified is smaller than the number of semidefinite variables in the task.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_EMPTY_COLS" val="902">
   <cmnt>This warning is issued by the problem analyzer, if columns, in which all coefficients are zero, are found.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL" val="10030">
   <cmnt>The optimizer terminated due to some internal reason. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_VAR_TYPE" val="1258">
   <cmnt>An invalid variable type is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_NEW_VARIABLE" val="1169">
   <cmnt>Introducing new variables is now allowed. When a \comp{[variables]} section is present, it is not allowed to introduce new variables later in the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FLEXLM" val="1014">
   <cmnt>The FLEXlm license manager reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_GECO_PROBLEM" val="1164">
   <cmnt>The problem contains general convex terms that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL_STOP" val="10031">
   <cmnt>The optimizer terminated for internal reasons. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_INTS" val="7119">
   <cmnt>Too few ints are specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_INT" val="511">
   <cmnt>The parameter name is not recognized as a integer parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_REP_VAR" val="1303">
   <cmnt>A variable is included multiple times in the cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_PROBLEM" val="1500">
   <cmnt>Invalid problem type.
              Probably a nonconvex problem
              has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_N" val="7003">
   <cmnt>Invalid argument n.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_M" val="7002">
   <cmnt>Invalid argument m.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_K" val="7004">
   <cmnt>Invalid argument k.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_DUALIZER" val="950">
   <cmnt>No automatic dualizer is available for the specified problem. The primal problem is solved.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QOBJ" val="1114">
   <cmnt>The Q term in the objective
              is specified multiple times in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_IGNORED_CMIO" val="516">
   <cmnt>A parameter was ignored by the conic mixed integer optimizer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_UNLOCK" val="1047">
   <cmnt>Could not unlock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_VAL" val="1407">
   <cmnt>Invalid value in \comp{qcval}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LU_MAX_NUM_TRIES" val="2800">
   <cmnt>Could not compute the LU factors of the matrix within the maximum number of allowed tries.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DROPPED_NZ_QOBJ" val="201">
   <cmnt>One or more non-zero elements were dropped in the Q matrix in the objective.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BAR_VAR_DIM" val="3920">
   <cmnt>The dimension of a symmetric matrix variable has to greater than 0.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NEAR_REL_GAP" val="10003">
   <cmnt>The mixed-integer optimizer terminated because the near optimal relative gap tolerance was satisfied.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INVALID_REGEXP" val="3056">
   <cmnt>Syntax error in regexp or regexp longer than 1024.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_VERSION" val="1002">
   <cmnt>The license is valid for another version of \mosek{}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_VALUE" val="3943">
   <cmnt>The numerical value specified in a sparse symmetric matrix is not a value floating value.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DATA_FILE_EXT" val="1055">
   <cmnt>The data file format cannot be determined from the file name.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_DROP_VARIABLE" val="85">
   <cmnt>Ignored a variable because the variable was not previously defined.
              Usually this implies that a variable appears in the bound section but not in the objective or the constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_INDEX" val="1219">
   <cmnt>A double information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD" val="7114">
   <cmnt>Duplicate index in OBJCOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FACTOR" val="1650">
   <cmnt>An error occurred while factorizing a matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BRANCH_PRIORITY" val="3201">
   <cmnt>An invalid branching priority is specified. It should be nonnegative.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_STR" val="512">
   <cmnt>The parameter name is not recognized as a string parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCON" val="1240">
   <cmnt>The maximum number of constraints specified is smaller than the number of
              constraints in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_FEATURE" val="1018">
   <cmnt>A requested feature is not available in the license file(s). Most likely due to an incorrect license system setup.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_NONEXISTING_NAME" val="1162">
   <cmnt>A variable never occurred in objective or constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_VAR_NAME" val="1104">
   <cmnt>An empty variable name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_INTS" val="7120">
   <cmnt>Too many ints are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INTERNAL" val="5010">
   <cmnt>A fatal error occurred in the mixed integer optimizer. Please contact MOSEK support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT" val="1027">
   <cmnt>The license server does not support the requested feature.
              Possible reasons for this error include:
              \begin{itemize}
              \item{ The feature has expired.}
              \item{ The feature's start date is later than today's date.}
              \item{ The version requested is higher than feature's the highest supported version.}
              \item{ A corrupted license file.}
              \end{itemize}Try restarting the license and inspect the license server debug file, usually called \texttt{lmgrd.log}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SPAR_MAX_LEN" val="66">
   <cmnt>A value for a string parameter is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_NO_SERVER_LINE" val="1028">
   <cmnt>There is no \texttt{SERVER} line in the license file. All non-zero license count features need at least one \texttt{SERVER} line.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_INDEX" val="1300">
   <cmnt>An index of a non-existing cone has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PRO_ITEM" val="1281">
   <cmnt>An invalid problem is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_ACOORD" val="7116">
   <cmnt>Duplicate index in ACOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_SMALL" val="1408">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS" val="10015">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD2" val="1125">
   <cmnt>A tab char occurred in field 2.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MIO_INFEASIBLE_FINAL" val="270">
   <cmnt>The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_SNX_FOR_BAS_SOL" val="2953">
   <cmnt>$s_n^x$ is not available for the basis solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD5" val="1127">
   <cmnt>A tab char occurred in field 5.</cmnt>
  </c>
  <c name="MSK_RES_WRN_WRITE_DISCARDED_CFIX" val="804">
   <cmnt>The fixed objective term could not be converted to a variable and was discarded in the output file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL_TEST_FAILED" val="3500">
   <cmnt>An internal unit test function failed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_OPEN" val="1052">
   <cmnt>Error while opening a file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_IGNORE_INTEGER" val="250">
   <cmnt>Ignored integer constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_TASK" val="1064">
   <cmnt>The \texttt{task} is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES" val="4500">
   <cmnt>Two constraint names are identical.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUMERICAL_PROBLEM" val="10025">
   <cmnt>The optimizer terminated due to numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_FATAL_ERROR" val="3005">
   <cmnt>An internal error occurred in the API. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_OPTIMIZER" val="1550">
   <cmnt>An invalid optimizer has been chosen for the problem. This
              means that the simplex or the conic optimizer is chosen to
              optimize a nonlinear problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REMOVE_CONE_VARIABLE" val="1310">
   <cmnt>A variable cannot be removed because it will make a cone invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOL_FILE_INVALID_NUMBER" val="1350">
   <cmnt>An invalid number is specified in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_READ" val="1053">
   <cmnt>File read error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UPPER_TRIANGLE" val="6020">
   <cmnt>An element in the upper triangle of a lower triangular matrix is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILTER" val="300">
   <cmnt>Invalid solution filter is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NO_OBJECTIVE" val="1110">
   <cmnt>No objective is defined in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_CONVERSION_FAIL" val="7200">
   <cmnt>A constraint could not be converted in conic form.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_OVERLAP" val="1302">
   <cmnt>A new cone which variables overlap with an existing cone has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_STREAM" val="1062">
   <cmnt>An invalid stream is referenced.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_AMPL_STUB" val="3700">
   <cmnt>Invalid AMPL stub.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CON_FX" val="54">
   <cmnt>An equality constraint is fixed to a numerically large value. This can cause numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_SYNTAX" val="7106">
   <cmnt>Invalid syntax.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_C_ZERO" val="901">
   <cmnt>This warning is issued by the problem analyzer, if the coefficients in the linear part of the objective are all zero.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TASK_INVALID" val="2561">
   <cmnt>The Task file is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_CON_KEY" val="1107">
   <cmnt>An invalid constraint key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_INFEAS_CER" val="2001">
   <cmnt>A certificate of infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND" val="1702">
   <cmnt>The upper bound is less than the lower bound for a variable or a constraint.
              %A ranged constraint on a bound or variable has a lower bound that is larger than its upper bound.
              Please correct this before running the feasibility repair.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BRANCH_DIRECTION" val="3200">
   <cmnt>An invalid branching direction is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION" val="7113">
   <cmnt>Invalid domain dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFINITE_BOUND" val="1400">
   <cmnt>A numerically huge bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANSB" val="7006">
   <cmnt>Invalid argument transb.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_IDX" val="1246">
   <cmnt>A specified index is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANSA" val="7005">
   <cmnt>Invalid argument transa.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IDENTICAL_TASKS" val="3101">
   <cmnt>Some tasks related to this function call were identical. Unique tasks were expected.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_MPS_INVALID_NAME" val="1153">
   <cmnt>An invalid name is created while writing an MPS file. Usually this will make the MPS file unreadable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_WHICHSOL" val="1228">
   <cmnt>\texttt{whichsol} is invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_SERVER" val="501">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJSENSE" val="1122">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK_STR" val="1269">
   <cmnt>Invalid status key string encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUP_NAME" val="1071">
   <cmnt>The same name was used multiple times for the same problem item type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_BOUND" val="51">
   <cmnt>A numerically large bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPTIMIZER_LICENSE" val="1013">
   <cmnt>The optimizer required is not licensed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_LICENSE" val="1007">
   <cmnt>Invalid license file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLITEM" val="1237">
   <cmnt>The solution item number \comp{solitem} is invalid. Please note that \mskitem{solitem.snx}
              is invalid for the basic solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_POSTSOLVE" val="1580">
   <cmnt>An error occurred during the postsolve. Please contact \mosek{} support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PLATFORM_NOT_LICENSED" val="1019">
   <cmnt>A requested license feature is not available for the required platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_LO" val="3054">
   <cmnt>Analysis of lower bound requested for an index, where no lower bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_SPLITTED_VAR" val="1111">
   <cmnt>All elements in a column of the $A$ matrix must be specified consecutively.
              Hence, it is illegal to specify non-zero elements in $A$ for variable 1, then for variable 2 and then variable 1 again.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_COND_INIT" val="1049">
   <cmnt>Could not initialize a condition.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_PROBLEM_TYPE" val="6000">
   <cmnt>An invalid problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_NO_VARIABLES" val="7102">
   <cmnt>No variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHITEM_NOT_ALLOWED" val="1238">
   <cmnt>\comp{whichitem} is unacceptable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEWER_DLL" val="1036">
   <cmnt>The dynamic link library is newer than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL" val="1289">
   <cmnt>An maximum length that is too small has been specfified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_EMPTY_NAME" val="502">
   <cmnt>A variable or constraint name is empty. The output file may be invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PROB_LICENSE" val="1006">
   <cmnt>The software is not licensed to solve the problem.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_CLOSE_BOUNDS" val="903">
   <cmnt>This warning is issued by problem analyzer, if ranged constraints or variables with very close upper and lower bounds are detected.  One should consider treating such constraints as equalities and such variables as constants.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARG_IS_TOO_SMALL" val="1226">
   <cmnt>The value of a argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_NON_UNIQUE_NAME" val="1161">
   <cmnt>An auto-generated name is not unique.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_NAME" val="1109">
   <cmnt>An invalid section name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FILE_FORMAT" val="1157">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_CONNECT" val="1021">
   <cmnt>\mosek{} cannot connect to the license server.
              Most likely the license server is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES" val="4501">
   <cmnt>Two variable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BK" val="1255">
   <cmnt>Invalid bound key.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_DOUBLE_DATA" val="1450">
   <cmnt>An invalid floating point value was used in some double data.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_MAX_LEN" val="1750">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ORD_INVALID_BRANCH_DIR" val="1130">
   <cmnt>An invalid branch direction key is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITING_FILE" val="1166">
   <cmnt>An error occurred while writing file</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_CON_NAME" val="1105">
   <cmnt>An undefined constraint name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE" val="5005">
   <cmnt>The value of a function argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_ITERATIONS" val="10000">
   <cmnt>The optimizer terminated at the maximum number of iterations.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_VAR" val="352">
   <cmnt>One or more lines in the variable section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_SMALL" val="1203">
   <cmnt>An index in an argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NEAR_ABS_GAP" val="10004">
   <cmnt>The mixed-integer optimizer terminated because the near optimal absolute gap tolerance was satisfied.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_ACCMODE" val="2520">
   <cmnt>An invalid access mode is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTI" val="1286">
   <cmnt>Invalid \comp{lasti}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_INIT_ENV" val="1063">
   <cmnt>\comp{env} is not initialized.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEF_SOLUTION" val="1265">
   <cmnt>\mosek{} has the following solution types:
              %
              \begin{itemize}
              \item{ an interior-point solution,}
              \item{ an basic solution,}
              \item{ and an integer solution.}
              \end{itemize}
              %
              Each optimizer may set one or more of these solutions; e.g by default a successful optimization with the interior-point optimizer defines the interior-point solution,
              and, for linear problems, also the basic solution. This error occurs when asking for a solution or for information
              about a solution that is not defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTJ" val="1288">
   <cmnt>Invalid \comp{lastj}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_STR_VALUE" val="515">
   <cmnt>The string is not recognized as a symbolic value for the parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_NAME" val="1234">
   <cmnt>A long integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MISSING_LICENSE_FILE" val="1008">
   <cmnt>\mosek{} cannot license file or a token server. See the \mosek{} installation manual for details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_NUMERICAL" val="3058">
   <cmnt>Numerical difficulties encountered performing the sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL" val="2950">
   <cmnt>No dual information is available for the integer solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OVERFLOW" val="1590">
   <cmnt>A computation produced an overflow i.e. a very large number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTI" val="1285">
   <cmnt>Invalid \comp{firsti}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIXED_PROBLEM" val="1501">
   <cmnt>The problem contains both conic and nonlinear constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX" val="3941">
   <cmnt>A column index specified for sparse symmetric maxtrix is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUX" val="1472">
   <cmnt>$u^x$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON" val="1017">
   <cmnt>The MOSEKLM license manager daemon is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE_STR" val="1306">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUC" val="1462">
   <cmnt>$u^c$ contains an invalid floating point value, i.e. a \texttt{NaN}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_INDEX" val="1210">
   <cmnt>Parameter index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE" val="1000">
   <cmnt>Invalid license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BARVAR_NAME" val="1079">
   <cmnt>An invalid symmetric matrix variable name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX" val="1235">
   <cmnt>An index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTJ" val="1287">
   <cmnt>Invalid \comp{firstj}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE" val="3080">
   <cmnt>Sensitivity analysis cannot be performed for the spcified problem. Sensitivity analysis is only possible for linear problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_NUMCORES" val="3900">
   <cmnt>The computer contains more cpu cores than the license allows for.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BARX_FOR_SOLUTION" val="3915">
   <cmnt>There is no $\bar{X}$ available for the solution specified. In particular note there are no $\bar{X}$ defined for the basic and integer solutions.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMI" val="2503">
   <cmnt>Invalid numi.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMJ" val="2504">
   <cmnt>Invalid numj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER" val="7131">
   <cmnt>An invalid node optimizer was selected for the problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_OPERATOR" val="3103">
   <cmnt>The code list data was invalid. An unknown operator was used.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_BRANCHES" val="10009">
   <cmnt>The mixed-integer optimizer terminated as to the maximum number of branches was reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_DUP_SLACK_NAME" val="1152">
   <cmnt>The name of the slack variable added to a ranged constraint already exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_FORMAT" val="1158">
   <cmnt>Problem cannot be written as an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_CON_NAME" val="1103">
   <cmnt>An empty constraint name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_OBJ_SENSE" val="7101">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ELIMINATOR_SPACE" val="801">
   <cmnt>The eliminator is skipped at least once due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_COL" val="710">
   <cmnt>One or more (near) zero elements are specified in a sparse column of a matrix.
              It is redundant to specify zero elements. Hence, it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK" val="800">
   <cmnt>The linear dependency check(s) is not completed. Normally this is not an important warning unless the optimization problem has been formulated with
              linear dependencies which is bad practice.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SYM_MAT_DIM" val="3950">
   <cmnt>A sparse symmetric matrix of invalid dimension is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SURPLUS" val="1275">
   <cmnt>Invalid surplus.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMQNZ" val="1243">
   <cmnt>The maximum number of non-zeros specified for the $Q$ matrixes is smaller than the
              number of non-zeros in the current $Q$ matrixes.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_UTF8" val="2900">
   <cmnt>An invalid UTF8 string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJ_NAME" val="1075">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME" val="1205">
   <cmnt>The parameter name is not correct.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_CODELIST" val="3102">
   <cmnt>The code list data was invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONCURRENT_OPTIMIZER" val="3059">
   <cmnt>An unsupported optimizer was chosen for use with the concurrent optimizer.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_AIJ" val="62">
   <cmnt>A numerically large value is specified for an $a_{i,j}$ element in $A$.
              The parameter \mskitem{dparam.data_tol_aij_large} controls when an $a_{i,j}$ is considered large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_VAR" val="7109">
   <cmnt>Duplicate VAR keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_FILE" val="1100">
   <cmnt>An error occurred while reading an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_GLOBAL_OPTIMIZER" val="251">
   <cmnt>No global optimizer is available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED" val="1701">
   <cmnt>The relaxed problem could not be solved to optimality. Please consult the log file for further details.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_NUM_SETBACKS" val="10020">
   <cmnt>The optimizer terminated as the maximum number of set-backs was reached.
              This indicates
              % serious
              numerical problems and a possibly badly formulated problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_VAR" val="1011">
   <cmnt>The problem has too many variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR" val="72">
   <cmnt>A BOUNDS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INT64_TO_INT32_CAST" val="3800">
   <cmnt>An 32 bit integer could not cast to a 64 bit integer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_MISSING_RETURN" val="3106">
   <cmnt>The code list data was invalid. Missing return operation in function.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_UP_BOUND" val="53">
   <cmnt>A numerically large upper bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFEAS_UNDEFINED" val="3910">
   <cmnt>The requested value is not defined for this solution type.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_NONLINEAR_FUNCTION_WRITE" val="450">
   <cmnt>The problem contains a general nonlinear function in either the objective or the constraints. Such a nonlinear function cannot be written to a disk file.
            Note that quadratic terms when inputted explicitly can be written to disk.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_UPPER_TRIANGLE" val="1417">
   <cmnt>An element in the upper triangle of a $Q^k$ is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_ORDER" val="1115">
   <cmnt>The sections in the MPS data file
              are not in the correct order.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_CON" val="7108">
   <cmnt>Duplicate CON keyword.</cmnt>
  </c>
  <c name="MSK_RES_WRN_CONSTRUCT_SOLUTION_INFEAS" val="805">
   <cmnt>After fixing the integer variables at the suggested values then the problem is infeasible.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_NSD" val="1294">
   <cmnt>The quadratic constraint matrix is not negative semidefinite as expected for a constraint with finite lower bound. This results in a nonconvex problem.
              The parameter \mskitem{dparam.check_convexity_rel_tol} can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIXED_BOUND_VALUES" val="1425">
   <cmnt>A fixed constraint/variable has been specified using the bound keys but the numerical value of the lower and upper
              bound is different.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR" val="70">
   <cmnt>An RHS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_Y_IS_UNDEFINED" val="1449">
   <cmnt>The solution item $y$ is undefined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE" val="1020">
   <cmnt>The license system cannot allocate the memory required.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_NOT_LOADED" val="1553">
   <cmnt>The mixed-integer optimizer is not loaded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_VARIABLES" val="7104">
   <cmnt>Too many variables specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_MAXNUMANZ" val="1252">
   <cmnt>The maximum number of non-zeros specified for $A$ is smaller than the
              number of non-zeros in the current $A$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TASK_INCOMPATIBLE" val="2560">
   <cmnt>The Task file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJECTIVE_SENSE" val="1445">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_CONE_NAMES" val="853">
   <cmnt>Two cone names are identical.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NAME_MAX_LEN" val="65">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_WRN_WRITE_CHANGED_NAMES" val="803">
   <cmnt>Some names were changed because they were invalid for the output file format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FORMAT" val="1160">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_GENERAL_NL" val="4010">
   <cmnt>The file format does not support a problem with general nonlinear terms.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_OVERLAP" val="1118">
   <cmnt>A variable is specified to be a member of several cones.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_RELAXS" val="10008">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of relaxations was reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SOL_FILE_NAME" val="1057">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_USER_NLO_EVAL" val="1433">
   <cmnt>The user-defined nonlinear function reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OLDER_DLL" val="1035">
   <cmnt>The dynamic link library is older than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_REPEAT" val="1119">
   <cmnt>A variable is repeated within the \comp{CSECTION}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_VAL" val="1403">
   <cmnt>Invalid value in \comp{qoval}.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR" val="71">
   <cmnt>A RANGE vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_LEAKING" val="1080">
   <cmnt>\mosek{} is leaking memory. This can be due to either an incorrect use of \mosek{} or a bug.</cmnt>
  </c>
  <c name="MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE" val="3600">
   <cmnt>The problem type is not supported by the XML format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_MISSING_END_TAG" val="1159">
   <cmnt>Syntax error in LP file. Possibly missing End tag.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_TIME" val="10001">
   <cmnt>The optimizer terminated at the maximum amount of time.</cmnt>
  </c>
  <c name="MSK_RES_WRN_QUAD_CONES_WITH_ROOT_FIXED_AT_ZERO" val="930">
   <cmnt>For at least one quadratic cone the root is fixed at (nearly) zero. This may cause problems such as a very large dual solution.
              Therefore, it is recommended to remove such cones before optimizing the problems, or to fix all the variables in the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHSOL" val="1236">
   <cmnt>The solution defined by comp{whichsol} does not exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_OVERLAP_APPEND" val="1307">
   <cmnt>The cone to be appended has one variable which is already memeber of another cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_SINGULAR" val="1615">
   <cmnt>The basis is singular and hence cannot be factored.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_MANY_THREADS_CONCURRENT" val="750">
   <cmnt>The concurrent optimizer employs more threads than available. This will lead to poor performance.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_LARGE" val="1409">
   <cmnt>Invalid value in \comp{qcsubi}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_UNDEF_NAME" val="3051">
   <cmnt>An undefined name was encountered in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_OLD_QUAD_FORMAT" val="80">
   <cmnt>Missing '/2' after quadratic expressions in bound or objective.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_MARKER" val="1102">
   <cmnt>An invalid marker has been specified in the MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_SURPLUS" val="1263">
   <cmnt>Negative surplus.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKX" val="1257">
   <cmnt>An invalid bound key is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJ_NAME" val="1128">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE" val="1222">
   <cmnt>An index in an array argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_INFO_FOR_ITG_SOL" val="3300">
   <cmnt>Dual information is not available for the integer solution.</cmnt>
  </c>
  <c name="MSK_RES_TRM_OBJECTIVE_RANGE" val="10002">
   <cmnt>The optimizer terminated on the bound of the objective range.</cmnt>
  </c>
  <c name="MSK_RES_WRN_UNDEF_SOL_FILE_NAME" val="350">
   <cmnt>Undefined name occurred in a solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKC" val="1256">
   <cmnt>Invalid bound key is specified for a constraint.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BLANK_NAME" val="1070">
   <cmnt>An all blank name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRST" val="1261">
   <cmnt>Invalid \comp{first}.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_C" val="1375">
   <cmnt>A huge value in absolute size is specified for one $c_{j}$.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE" val="1446">
   <cmnt>The objective sense has not been specified before the optimization.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ" val="1245">
   <cmnt>The maximum number of non-zeros specified is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKI" val="2501">
   <cmnt>Invalid value in marki.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKJ" val="2502">
   <cmnt>Invalid value in markj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_IS_NULL" val="1760">
   <cmnt>The name buffer is a NULL pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_UPLO" val="7007">
   <cmnt>Invalid argument uplo.</cmnt>
  </c>
 </sec>
 <sec id="MSKmionodeseltypee" type="constants">
  <c name="MSK_MIO_NODE_SELECTION_PSEUDO" val="5">
   <cmnt>The optimizer employs selects the node based on a pseudo cost estimate.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_HYBRID" val="4">
   <cmnt>The optimizer employs a hybrid strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_FREE" val="0">
   <cmnt>The optimizer decides the node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_WORST" val="3">
   <cmnt>The optimizer employs a worst bound node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_BEST" val="2">
   <cmnt>The optimizer employs a best bound node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_FIRST" val="1">
   <cmnt>The optimizer employs a depth first node selection strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKtransposee" type="enum">
  <c name="MSK_TRANSPOSE_YES" val="1">
   <cmnt>A transpose is applied.</cmnt>
  </c>
  <c name="MSK_TRANSPOSE_NO" val="0">
   <cmnt>No transpose is applied.</cmnt>
  </c>
 </sec>
 <sec id="MSKonoffkeye" type="constants">
  <c name="MSK_ON" val="1">
   <cmnt>Switch the option on.</cmnt>
  </c>
  <c name="MSK_OFF" val="0">
   <cmnt>Switch the option off.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimdegene" type="enum">
  <c name="MSK_SIM_DEGEN_NONE" val="0">
   <cmnt>The simplex optimizer should use no degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MODERATE" val="3">
   <cmnt>The simplex optimizer should use a moderate degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MINIMUM" val="4">
   <cmnt>The simplex optimizer should use a minimum degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_AGGRESSIVE" val="2">
   <cmnt>The simplex optimizer should use an aggressive degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_FREE" val="1">
   <cmnt>The simplex optimizer chooses the degeneration strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKdataformate" type="constants">
  <c name="MSK_DATA_FORMAT_XML" val="4">
   <cmnt>The data file is an XML formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_TASK" val="6">
   <cmnt>Generic task dump file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_EXTENSION" val="0">
   <cmnt>The file extension is used to determine the data file format.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_CB" val="7">
   <cmnt>Conic benchmark format.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_FREE_MPS" val="5">
   <cmnt>The data data a free MPS formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_LP" val="2">
   <cmnt>The data file is LP formatted.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_OP" val="3">
   <cmnt>The data file is an optimization problem formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_MPS" val="1">
   <cmnt>The data file is MPS formatted.</cmnt>
  </c>
 </sec>
 <sec id="MSKorderingtypee" type="constants">
  <c name="MSK_ORDER_METHOD_NONE" val="5">
   <cmnt>No ordering is used.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_FORCE_GRAPHPAR" val="4">
   <cmnt>Always use the graph partitioning based ordering even if it is worse that the approximate minimum local fill ordering.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_APPMINLOC" val="1">
   <cmnt>Approximate minimum local fill-in ordering is employed.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_TRY_GRAPHPAR" val="3">
   <cmnt>Always try the the graph partitioning based ordering.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_FREE" val="0">
   <cmnt>The ordering method is chosen automatically.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_EXPERIMENTAL" val="2">
   <cmnt>This option should not be used.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemtypee" type="enum">
  <c name="MSK_PROBTYPE_QCQO" val="2">
   <cmnt>The problem is a quadratically constrained optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_LO" val="0">
   <cmnt>The problem is
a linear optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_CONIC" val="4">
   <cmnt>A conic optimization.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_GECO" val="3">
   <cmnt>General convex optimization.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_MIXED" val="5">
   <cmnt>General nonlinear constraints and conic constraints. This combination can not be solved by \mosek{}.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_QO" val="1">
   <cmnt>The problem is a quadratic optimization problem.</cmnt>
  </c>
 </sec>
 <sec id="MSKinftypee" type="enum">
  <c name="MSK_INF_DOU_TYPE" val="0">
   <cmnt>Is a double information type.</cmnt>
  </c>
  <c name="MSK_INF_LINT_TYPE" val="2">
   <cmnt>Is a long integer.</cmnt>
  </c>
  <c name="MSK_INF_INT_TYPE" val="1">
   <cmnt>Is an integer.</cmnt>
  </c>
 </sec>
 <sec id="MSKdparame" type="parameters">
  <p name="MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH" val="39">
   <cmnt>If the lower objective cut is less than the value of this parameter value,
                    then the lower objective cut i.e. \mskitem{dparam.lower_obj_cut}
                    is treated as $-\infty$.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-0.5e30</default>
  </p>
  <p name="MSK_DPAR_MIO_MAX_TIME" val="42">
   <cmnt>This parameter limits the maximum time spent by the mixed-integer optimizer.
                    A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_S" val="2">
   <cmnt>Maximum absolute dual bound violation in
                    an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_S" val="63">
   <cmnt>Absolute zero tolerance employed for $s_i$ in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT" val="68">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal
                    objective value is outside,
                    [\mskitem{dparam.lower_obj_cut}, \mskitem{dparam.upper_obj_cut}],
                    then \mosek{} is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e30</default>
   <seealso key="MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH"/>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_DFEAS" val="15">
   <cmnt>Dual feasibility tolerance used by the conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_LARGE" val="7">
   <cmnt>An element in $A$ which is larger
                    than this value in absolute size causes a
                    warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e10</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_GAP" val="48">
   <cmnt>Absolute optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH" val="69">
   <cmnt>If the upper objective cut is greater than the value of this value parameter, then the
                    the upper objective cut \mskitem{dparam.upper_obj_cut} is treated as $\infty$.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.5e30</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_RELAX_INT" val="49">
   <cmnt>Absolute relaxation tolerance of the integer constraints. I.e.
                    $\min(|x|-\lfloor x \rfloor,\lceil x \rceil - |x|)$ is less than the tolerance
                    then the integer restrictions assumed to be satisfied.</cmnt>
   <lower_bound>1e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-5</default>
  </p>
  <p name="MSK_DPAR_NONCONVEX_TOL_OPT" val="58">
   <cmnt>Optimality tolerance used by the nonconvex optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_NONCONVEX_TOL_FEAS" val="57">
   <cmnt>Feasibility tolerance used by the nonconvex optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_MAX_CUT_FRAC_RHS" val="51">
   <cmnt>Maximum value of fractional part of right hand side to generate CMIR and CG cuts for.
                  A value of $0.0$ means that the value is selected automatically.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_SIMPLEX_ABS_TOL_PIV" val="67">
   <cmnt>Absolute pivot tolerance employed by the simplex optimizers.</cmnt>
   <lower_bound>1.0e-12</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT" val="53">
   <cmnt>If the relative improvement of the dual bound is smaller than this value, the solver will terminate the root cut generation. 
                    A value of $0.0$ means that the value is selected automatically.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_MIO_HEURISTIC_TIME" val="41">
   <cmnt>Minimum amount of time to be used in the heuristic search for a good feasible integer solution.
                    A negative values implies that the optimizer decides the amount of time to be spent in the heuristic.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_CHECK_CONVEXITY_REL_TOL" val="4">
   <cmnt>This parameter controls when the full convexity check declares a problem to be non-convex.
                     Increasing this tolerance relaxes the criteria for declaring the problem non-convex.

                     A problem is declared non-convex if negative (positive) pivot elements are detected in the cholesky factor of a matrix
                     which is required to be PSD (NSD). This parameter controles how much this non-negativity requirement may be violated.

                     If $d_i$ is the pivot element for column $i$, then the matrix $Q$ is considered to not be PSD if:
                     \[
                         d_i \leq - |Q_{ii}| * \mathtt{check\_convexity\_rel\_tol}
                     \]</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-10</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_X" val="64">
   <cmnt>Absolute zero tolerance employed for $x_j$ in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_MU_RED" val="23">
   <cmnt>Relative complementarity gap tolerance.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_MIO_NEAR_TOL_REL_GAP" val="45">
   <cmnt>The mixed-integer optimizer is terminated when this tolerance is satisfied.
                    This termination criteria is delayed. See \mskitem{dparam.mio_disable_term_time} for details.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-3</default>
   <seealso key="MSK_DPAR_MIO_DISABLE_TERM_TIME"/>
  </p>
  <p name="MSK_DPAR_MIO_TOL_MIN_CUT_FRAC_RHS" val="52">
   <cmnt>Minimum value of fractional part of right hand side to generate CMIR and CG cuts for.
                    A value of $0.0$ means that the value is selected automatically.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_REL_LINDEP" val="62">
   <cmnt>Relative tolerance employed by the 
                    linear dependency checker.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ" val="5">
   <cmnt>Absolute zero tolerance for elements in $A$. If any value $A_{ij}$ is smaller than this parameter in absolute terms MOSEK will treat the values as zero and generate a warning.</cmnt>
   <lower_bound>1.0e-16</lower_bound>
   <upper_bound>1.0e-6</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_FEASREPAIR_TOL" val="14">
   <cmnt>Tolerance for constraint enforcing upper bound on
                    sum of weighted violations in feasibility repair.</cmnt>
   <lower_bound>1.0e-16</lower_bound>
   <upper_bound>1.0e+16</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DSAFE" val="29">
   <cmnt>Controls the initial dual starting point used by
                    the interior-point optimizer. If the interior-point optimizer
                    converges slowly.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_FEAS" val="50">
   <cmnt>Feasibility tolerance for mixed integer solver. Any solution with
                    maximum infeasibility below this value will be considered feasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_INFEAS" val="30">
   <cmnt>Controls when the optimizer declares the model
                    primal or dual infeasible. A small number means
                    the optimizer gets more conservative about
                    declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_NEAR_REL" val="24">
   <cmnt>If the \mosek{} nonlinear interior-point optimizer
                    cannot compute a solution that has the prescribed
                    accuracy, then it will multiply the termination
                    tolerances with value of this parameter.  If the
                    solution then satisfies the termination criteria,
                    then the solution is denoted near optimal, near
                    feasible and so forth.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000.0</default>
  </p>
  <p name="MSK_DPAR_OPTIMIZER_MAX_TIME" val="59">
   <cmnt>Maximum amount of time the optimizer is allowed to spent on the optimization.
                    A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_X" val="13">
   <cmnt>Zero tolerance for constraints and variables i.e.
                    if the distance between the lower and upper bound
                    is less than this value, then the lower and lower
                    bound is considered identical.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_ANA_SOL_INFEAS_TOL" val="0">
   <cmnt>If a constraint violates its bound with an amount larger than this value,
                   the constraint name, index and violation will be printed by the solution analyzer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-6</default>
  </p>
  <p name="MSK_DPAR_MIO_REL_ADD_CUT_LIMITED" val="46">
   <cmnt>Controls how many cuts the mixed-integer optimizer is
                    allowed to add to the problem.  Let $\alpha$ be the value
                    of this parameter and $m$ the number constraints, then
                    mixed-integer optimizer is allowed to $\alpha m$ cuts.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>2.0</upper_bound>
   <default>0.75</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_MU_RED" val="31">
   <cmnt>Relative complementarity gap tolerance.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_MU_RED" val="17">
   <cmnt>Relative complementarity gap tolerance feasibility
                    tolerance used by the conic interior-point
                    optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_REL_GAP" val="20">
   <cmnt>Relative gap termination tolerance used by the
                    conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-7</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_LOWER_OBJ_CUT" val="38">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal
                    objective value is outside,
                    the interval [\mskitem{dparam.lower_obj_cut}, \mskitem{dparam.upper_obj_cut}],
                    then \mosek{} is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0e30</default>
   <seealso key="MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH"/>
  </p>
  <p name="MSK_DPAR_MIO_DISABLE_TERM_TIME" val="40">
   <cmnt>The termination criteria governed by
                    %
                    \begin{itemize}
                       \item{ \mskitem{iparam.mio_max_num_relaxs}}
                       \item{ \mskitem{iparam.mio_max_num_branches}}
                       \item{ \mskitem{dparam.mio_near_tol_abs_gap}}
                       \item{ \mskitem{dparam.mio_near_tol_rel_gap}}
                    \end{itemize}
                    %
                    is disabled the first $n$ seconds. This parameter specifies the number $n$.
                    A negative value is identical to infinity i.e. the termination criteria are never checked.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
   <seealso key="MSK_IPAR_MIO_MAX_NUM_RELAXS"/>
   <seealso key="MSK_IPAR_MIO_MAX_NUM_BRANCHES"/>
   <seealso key="MSK_DPAR_MIO_NEAR_TOL_ABS_GAP"/>
   <seealso key="MSK_DPAR_MIO_NEAR_TOL_REL_GAP"/>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_STEP" val="36">
   <cmnt>Relative step size to the boundary
                    for linear and quadratic optimization problems.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.9999</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_X" val="56">
   <cmnt>Absolute solution tolerance used in mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_C_HUGE" val="10">
   <cmnt>An element in $c$ which is larger
                    than the value of this parameter  in absolute terms is considered
                    to be huge and generates an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_SIM_LU_TOL_REL_PIV" val="66">
   <cmnt>Relative pivot tolerance employed when computing the LU factorization
                    of the basis in the simplex optimizers and in the basis identification procedure.

                    A value closer to $1.0$ generally improves numerical stability but typically also implies an
                    increase in the computational work.</cmnt>
   <lower_bound>1.0e-6</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.01</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_CJ_LARGE" val="11">
   <cmnt>An element in $c$ which is larger
                    than this value in absolute terms causes a
                    warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_REL_STEP" val="27">
   <cmnt>Relative step size to the boundary
                    for general nonlinear optimization problems.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>0.9999999</upper_bound>
   <default>0.995</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_STEP_SIZE" val="37">
   <cmnt>If the step size falls below the value of this parameter, then
                    the interior-point optimizer assumes that it is stalled. In other words the interior-point optimizer does not make any progress and therefore it is better stop.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PFEAS" val="33">
   <cmnt>Primal feasibility tolerance used for
                    linear and quadratic optimization problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_BASIS_REL_TOL_S" val="1">
   <cmnt>Maximum relative dual bound violation allowed in an optimal
                    basic solution.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP" val="60">
   <cmnt>Absolute tolerance employed by the 
                    linear dependency checker.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_INFEAS" val="16">
   <cmnt>Controls when the conic interior-point optimizer declares
                    the model primal or dual infeasible. A small number means the optimizer
                    gets more conservative about declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_MIO_REL_GAP_CONST" val="47">
   <cmnt>This value is used to compute the relative gap for the solution to an integer optimization problem.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_AIJ" val="61">
   <cmnt>Absolute zero tolerance employed for $a_{ij}$ in the presolve.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_MIO_MAX_TIME_APRX_OPT" val="43">
   <cmnt>Number of seconds spent by the mixed-integer optimizer before the
                    \mskitem{dparam.mio_tol_rel_relax_int} is applied.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>60</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PATH" val="32">
   <cmnt>Controls how close
                    the interior-point optimizer follows the central path. A large
                    value of this parameter means the central is
                    followed very closely. On numerical unstable
                    problems it may be worthwhile to increase this
                    parameter.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>0.9999</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_MERIT_BAL" val="21">
   <cmnt>Controls if the complementarity and infeasibility is converging to zero
                    at about equal rates.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>0.99</upper_bound>
   <default>1.0e-4</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_X" val="3">
   <cmnt>Maximum absolute primal bound violation allowed
                    in an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_GAP" val="35">
   <cmnt>Relative gap termination tolerance.</cmnt>
   <lower_bound>1.0e-14</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_HUGE" val="6">
   <cmnt>An element in $A$ which is larger
                    than this value in absolute size causes an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e20</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_WRN" val="9">
   <cmnt>If a bound value is larger than this value
                    in absolute size, then a warning message is issued.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_INF" val="8">
   <cmnt>Any bound which in absolute value
                    is greater than this parameter is
                    considered infinite.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PSAFE" val="34">
   <cmnt>Controls the initial primal starting point used by
                    the interior-point optimizer. If the interior-point optimizer
                    converges slowly and/or the constraint or variable bounds are very
                    large, then it may be worthwhile to increase this value.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL" val="18">
   <cmnt>If \mosek{} cannot compute a solution that has the prescribed accuracy,
                    then it will multiply the termination tolerances with value of this parameter.
                    If the solution then satisfies the termination criteria, then the solution is denoted
                    near optimal, near feasible and so forth.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_PFEAS" val="25">
   <cmnt>Primal feasibility tolerance used when a nonlinear
                    model is solved.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_DFEAS" val="22">
   <cmnt>Dual feasibility tolerance used when a nonlinear
                    model is solved.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_GAP" val="54">
   <cmnt>Relative optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-4</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DFEAS" val="28">
   <cmnt>Dual feasibility tolerance used for
                    linear and quadratic optimization problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_MIO_NEAR_TOL_ABS_GAP" val="44">
   <cmnt>Relaxed absolute optimality tolerance employed by the mixed-integer optimizer.
                    This termination criteria is delayed. See \mskitem{dparam.mio_disable_term_time} for details.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.0</default>
   <seealso key="MSK_DPAR_MIO_DISABLE_TERM_TIME"/>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_RELAX_INT" val="55">
   <cmnt>Relative relaxation tolerance of the integer constraints. I.e
                    $(\min(|x|-\lfloor x \rfloor,\lceil x \rceil - |x|))$ is less than the tolerance times $|x|$
                    then the integer restrictions assumed to be satisfied.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL" val="65">
   <cmnt>This parameter determines when columns are dropped in incomplete cholesky factorization doing reformulation of quadratic problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-15</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_QIJ" val="12">
   <cmnt>Absolute zero tolerance for elements in
                    $Q$ matrixes.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_NL_TOL_REL_GAP" val="26">
   <cmnt>Relative gap termination tolerance for nonlinear problems.</cmnt>
   <lower_bound>1.0e-14</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_PFEAS" val="19">
   <cmnt>Primal feasibility tolerance used by the conic interior-point optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
 </sec>
 <sec id="MSKsimdupvece" type="enum">
  <c name="MSK_SIM_EXPLOIT_DUPVEC_ON" val="1">
   <cmnt>Allow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
 </sec>
 <sec id="MSKcompresstypee" type="constants">
  <c name="MSK_COMPRESS_GZIP" val="2">
   <cmnt>The type of compression used is gzip compatible.</cmnt>
  </c>
  <c name="MSK_COMPRESS_NONE" val="0">
   <cmnt>No compression is used.</cmnt>
  </c>
  <c name="MSK_COMPRESS_FREE" val="1">
   <cmnt>The type of compression used is chosen automatically.</cmnt>
  </c>
 </sec>
 <sec id="MSKnametypee" type="enum">
  <c name="MSK_NAME_TYPE_GEN" val="0">
   <cmnt>General names. However, no duplicate and blank names are allowed.</cmnt>
  </c>
  <c name="MSK_NAME_TYPE_LP" val="2">
   <cmnt>LP type names.</cmnt>
  </c>
  <c name="MSK_NAME_TYPE_MPS" val="1">
   <cmnt>MPS type names.</cmnt>
  </c>
 </sec>
 <sec id="MSKmpsformate" type="constants">
  <c name="MSK_MPS_FORMAT_STRICT" val="0">
   <cmnt>It is assumed that the input file satisfies
                    the MPS format strictly.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_RELAXED" val="1">
   <cmnt>It is assumed that the input file satisfies
                    a slightly relaxed version of the MPS format.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_FREE" val="2">
   <cmnt>It is assumed that the input file satisfies the free
                    MPS format. This implies that spaces
                    are not allowed in names. Otherwise
                    the format is free.</cmnt>
  </c>
 </sec>
 <sec id="MSKvariabletypee" type="enum">
  <c name="MSK_VAR_TYPE_INT" val="1">
   <cmnt>Is an integer variable.</cmnt>
  </c>
  <c name="MSK_VAR_TYPE_CONT" val="0">
   <cmnt>Is a continuous variable.</cmnt>
  </c>
 </sec>
 <sec id="MSKcheckconvexitytypee" type="constants">
  <c name="MSK_CHECK_CONVEXITY_SIMPLE" val="1">
   <cmnt>Perform simple and fast convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_NONE" val="0">
   <cmnt>No convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_FULL" val="2">
   <cmnt>Perform a full convexity check.</cmnt>
  </c>
 </sec>
 <sec id="MSKlanguagee" type="enum">
  <c name="MSK_LANG_DAN" val="1">
   <cmnt>Danish language selection</cmnt>
  </c>
  <c name="MSK_LANG_ENG" val="0">
   <cmnt>English language selection</cmnt>
  </c>
 </sec>
 <sec id="MSKstartpointtypee" type="constants">
  <c name="MSK_STARTING_POINT_GUESS" val="1">
   <cmnt>The optimizer guesses a starting point.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_SATISFY_BOUNDS" val="3">
   <cmnt>The starting point is choosen to satisfy all the simple bounds on nonlinear variables. If this starting point is employed,
                    then more care than usual should employed when choosing the bounds on the nonlinear variables. In particular very tight bounds
                    should be avoided.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_CONSTANT" val="2">
   <cmnt>The optimizer constructs a starting point by assigning a constant value to all primal and dual variables.
                    This starting point is normally robust.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_FREE" val="0">
   <cmnt>The starting point is chosen automatically.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoltypee" type="enum">
  <c name="MSK_SOL_ITG" val="2">
   <cmnt>The integer solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITR" val="0">
   <cmnt>The interior solution.</cmnt>
  </c>
  <c name="MSK_SOL_BAS" val="1">
   <cmnt>The basic solution.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingmethode" type="constants">
  <c name="MSK_SCALING_METHOD_POW2" val="0">
   <cmnt>Scales only with power of 2 leaving the mantissa untouched.</cmnt>
  </c>
  <c name="MSK_SCALING_METHOD_FREE" val="1">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
 </sec>
 <sec id="MSKvaluee" type="constants">
  <c name="MSK_MAX_STR_LEN" val="1024">
   <cmnt>Maximum string length allowed in \mosek.</cmnt>
  </c>
  <c name="MSK_LICENSE_BUFFER_LENGTH" val="20">
   <cmnt>The length of a license key buffer.</cmnt>
  </c>
 </sec>
 <sec id="MSKstakeye" type="enum">
  <c name="MSK_SK_SUPBAS" val="2">
   <cmnt>The constraint or variable is super basic.</cmnt>
  </c>
  <c name="MSK_SK_BAS" val="1">
   <cmnt>The constraint or variable is in the basis.</cmnt>
  </c>
  <c name="MSK_SK_FIX" val="5">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_SK_LOW" val="3">
   <cmnt>The constraint or variable is at its lower bound.</cmnt>
  </c>
  <c name="MSK_SK_INF" val="6">
   <cmnt>The constraint or variable is infeasible in the bounds.</cmnt>
  </c>
  <c name="MSK_SK_UNK" val="0">
   <cmnt>The status for the constraint or variable is unknown.</cmnt>
  </c>
  <c name="MSK_SK_UPR" val="4">
   <cmnt>The constraint or variable is at its upper bound.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimreforme" type="enum">
  <c name="MSK_SIM_REFORMULATION_ON" val="1">
   <cmnt>Allow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_AGGRESSIVE" val="3">
   <cmnt>The simplex optimizer should use an aggressive reformulation strategy.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
 </sec>
 <sec id="MSKiinfiteme" type="enum">
  <c name="MSK_IINF_RD_NUMINTVAR" val="54">
   <cmnt>Number of integer-constrained variables read.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_GCD_CUTS" val="32">
   <cmnt>Number of gcd cuts.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMBARVAR" val="51">
   <cmnt>Number of variables read.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_DISAGG_CUTS" val="30">
   <cmnt>Number of diasagg cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_SOLSTA" val="87">
   <cmnt>Solution status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_TRANSPOSES" val="96">
   <cmnt>Number of times the $A$ matrix is transposed. A large number
                    implies that \comp{maxnumanz} is too small or an inefficient usage of \mosek{}.
                    This will occur in particular if the code alternate between accessing rows and columns
                    of $A$.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_SOLVE_DUAL" val="85">
   <cmnt>Is non-zero if dual problem is solved.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCON" val="42">
   <cmnt>Number of constraints in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMVAR" val="49">
   <cmnt>Number of variables in the problem solved when the optimizer is called</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMVAR" val="74">
   <cmnt>Number of variables in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_REALLOC" val="95">
   <cmnt>Number of times the storage for storing $A$ has been changed.
                    A large value may indicates that memory fragmentation may occur.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_LATTICE_CUTS" val="37">
   <cmnt>Number of lattice cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_DEG_ITER" val="68">
   <cmnt>The number of primal network degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMQ" val="55">
   <cmnt>Number of nonempty Q matrixes read.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_FLOW_COVER_CUTS" val="31">
   <cmnt>Number of flow cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_BASIS_CUTS" val="24">
   <cmnt>Number of basis cuts.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON" val="0">
   <cmnt>Number of constraints in the problem.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_INT" val="11">
   <cmnt>Number of general integer variables.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_INF_ITER" val="66">
   <cmnt>The number of iterations taken with dual infeasibility in the network optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_CONT" val="8">
   <cmnt>Number of continuous variables.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_ITER" val="62">
   <cmnt>Number of dual simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_DEG_ITER" val="58">
   <cmnt>The number of dual degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_ITER" val="17">
   <cmnt>Number of interior-point iterations
                    since invoking the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMCON" val="73">
   <cmnt>Number of constraints in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_ITER" val="80">
   <cmnt>Number of primal dual simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_UP" val="5">
   <cmnt>Number of constraints with an upper bound and an infinite lower bound.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_KNAPSUR_COVER_CUTS" val="36">
   <cmnt>Number of knapsack cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_HOTSTART" val="77">
   <cmnt>If 1 then the primal dual simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_SOLVE_DUAL" val="19">
   <cmnt>Non-zero if the interior-point optimizer is solving the dual problem.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_HOTSTART" val="64">
   <cmnt>If 1 then the dual network simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_OPTIMIZE_RESPONSE" val="50">
   <cmnt>The reponse code returned by optimize.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_GOMORY_CUTS" val="33">
   <cmnt>Number of Gomory cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_PROSTA" val="92">
   <cmnt>Problem status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_COEF_REDC_CUTS" val="28">
   <cmnt>Number of coef. redc. cuts.</cmnt>
  </c>
  <c name="MSK_IINF_RD_PROTYPE" val="57">
   <cmnt>Problem type.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CARDGUB_CUTS" val="26">
   <cmnt>Number of cardgub cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_SOLSTA" val="93">
   <cmnt>Solution status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_LIFT_CUTS" val="38">
   <cmnt>Number of lift cuts.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_FR" val="2">
   <cmnt>Number of unbounded constraints.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_HOTSTART_LU" val="78">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMINT" val="43">
   <cmnt>Number of integer variables in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITG_SOLSTA" val="91">
   <cmnt>Solution status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_INF_ITER" val="61">
   <cmnt>The number of iterations taken with dual infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMVAR" val="44">
   <cmnt>Number of variables in the problem solved be the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_CONSTRUCT_SOLUTION" val="21">
   <cmnt>If this item has the value 0, then \mosek{} did not try to construct an initial integer feasible solution.
                    If the item has a positive value, then \mosek{} successfully constructed an initial integer feasible solution.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR" val="6">
   <cmnt>Number of variables in the problem.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_CACHE_FLUSHES" val="94">
   <cmnt>Number of times the cache of $A$ elements is flushed. A large number
                    implies that \comp{maxnumanz} is too small as well as an inefficient usage of \mosek{}.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_INT_PROSTA" val="88">
   <cmnt>Deprecated.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_DEG_ITER" val="63">
   <cmnt>The number of dual network degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_INT_SOLSTA" val="89">
   <cmnt>Degrecated.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMVAR" val="56">
   <cmnt>Number of variables read.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_DEG_ITER" val="76">
   <cmnt>The number of degenerate major iterations taken by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_LO" val="12">
   <cmnt>Number of variables with a lower bound and an
                  infinite upper bound.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_PROSTA" val="86">
   <cmnt>Problem status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_ITER" val="72">
   <cmnt>Number of primal network simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_LO" val="3">
   <cmnt>Number of constraints with a lower bound and an
                  infinite upper bound.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CONTRA_CUTS" val="29">
   <cmnt>Number of contra cuts.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_HOTSTART_LU" val="65">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the dual network simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_INF_ITER" val="71">
   <cmnt>The number of iterations taken with primal infeasibility in the network optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART" val="81">
   <cmnt>If 1 then the primal simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_BRANCH" val="25">
   <cmnt>Number of branches performed during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_GUB_COVER_CUTS" val="34">
   <cmnt>Number of GUB cover cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_RELAX" val="41">
   <cmnt>Number of relaxations solved during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_OBJ_CUTS" val="39">
   <cmnt>Number of obj cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_INT_SOLUTIONS" val="35">
   <cmnt>Number of integer feasible solutions that has been found.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART_LU" val="82">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_CONSTRUCT_NUM_ROUNDINGS" val="20">
   <cmnt>Number of values in the integer solution that is rounded to an integer value.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_EQ" val="1">
   <cmnt>Number of equality constraints.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_RA" val="13">
   <cmnt>Number of variables with finite lower and upper bounds.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_OBJ_BOUND_DEFINED" val="45">
   <cmnt>Non-zero if a valid objective bound has been found, otherwise zero.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_INF_ITER" val="83">
   <cmnt>The number of iterations taken with primal infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCON" val="52">
   <cmnt>Number of constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCONE" val="53">
   <cmnt>Number of conic constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_FR" val="10">
   <cmnt>Number of free variables.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_ACTIVE_NODES" val="23">
   <cmnt>Number of active brabch bound nodes.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_BIN" val="7">
   <cmnt>Number of binary (0-1) variables.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_HOTSTART_LU" val="70">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal network simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_ITER" val="84">
   <cmnt>Number of primal simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART" val="59">
   <cmnt>If 1 then the dual simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_INITIAL_SOLUTION" val="22">
   <cmnt>Is non-zero if an initial integer solution is specified.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_NUM_THREADS" val="18">
   <cmnt>Number of threads that the interior-point optimizer is using.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART_LU" val="60">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_UP" val="14">
   <cmnt>Number of variables with an upper bound and an infinite lower bound. This value is set by
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_DUAL_ITER" val="67">
   <cmnt>Number of dual network simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CLIQUE_CUTS" val="27">
   <cmnt>Number of clique cuts.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_EQ" val="9">
   <cmnt>Number of fixed variables.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_FACTOR_DIM_DENSE" val="16">
   <cmnt>Dimension of the dense sub system in factorization.</cmnt>
  </c>
  <c name="MSK_IINF_CONCURRENT_FASTEST_OPTIMIZER" val="15">
   <cmnt>The type of the optimizer that finished first in a concurrent optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_USER_OBJ_CUT" val="47">
   <cmnt>If it is non-zero, then the objective cut is used.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NETWORK_PRIMAL_HOTSTART" val="69">
   <cmnt>If 1 then the primal network simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DUAL_INF_ITER" val="79">
   <cmnt>The number of master iterations with dual infeasibility taken by the primal dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_RA" val="4">
   <cmnt>Number of constraints with finite lower and upper bounds.
                  \begin{MSKexcl}{!mex:cmdln}
                    This value is set by \mskitem{task.analyzeproblem}.
                  \end{MSKexcl}</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_PLAN_LOC_CUTS" val="40">
   <cmnt>Number of loc cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CUTS" val="46">
   <cmnt>Total number of cuts generated by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMCON" val="48">
   <cmnt>Number of constraints in the problem solved when the optimizer is called.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITG_PROSTA" val="90">
   <cmnt>Problem status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DEG_ITER" val="75">
   <cmnt>The number of primal degenerate iterations.</cmnt>
  </c>
 </sec>
 <sec id="MSKxmlwriteroutputtypee" type="enum">
  <c name="MSK_WRITE_XML_MODE_COL" val="1">
   <cmnt>Write in column order.</cmnt>
  </c>
  <c name="MSK_WRITE_XML_MODE_ROW" val="0">
   <cmnt>Write in row order.</cmnt>
  </c>
 </sec>
 <sec id="MSKoptimizertypee" type="constants">
  <c name="MSK_OPTIMIZER_INTPNT" val="1">
   <cmnt>The interior-point optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_CONCURRENT" val="10">
   <cmnt>The optimizer for nonconvex nonlinear problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_MIXED_INT_CONIC" val="8">
   <cmnt>The mixed-integer optimizer for conic and linear problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_MIXED_INT" val="9">
   <cmnt>The mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_DUAL_SIMPLEX" val="4">
   <cmnt>The dual simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_FREE" val="0">
   <cmnt>The optimizer is chosen automatically.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_PRIMAL_DUAL_SIMPLEX" val="5">
   <cmnt>The primal dual simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_CONIC" val="2">
   <cmnt>The optimizer for problems having conic constraints.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_NONCONVEX" val="11">
   <cmnt>The optimizer for nonconvex nonlinear problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_PRIMAL_SIMPLEX" val="3">
   <cmnt>The primal simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_NETWORK_PRIMAL_SIMPLEX" val="7">
   <cmnt>The network primal simplex optimizer is used. It is only applicable to pute network problems.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_FREE_SIMPLEX" val="6">
   <cmnt>One of the simplex optimizers is used.</cmnt>
  </c>
 </sec>
 <sec id="MSKpresolvemodee" type="constants">
  <c name="MSK_PRESOLVE_MODE_ON" val="1">
   <cmnt>The problem is presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_OFF" val="0">
   <cmnt>The problem is not presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_FREE" val="2">
   <cmnt>It is decided automatically whether to presolve before the problem is optimized.</cmnt>
  </c>
 </sec>
 <sec id="MSKmiocontsoltypee" type="constants">
  <c name="MSK_MIO_CONT_SOL_ITG" val="2">
   <cmnt>The reported interior-point and basic solutions are
                    a solution to the problem with all integer variables
                    fixed at the value they have in the integer solution.
                    A solution is only reported in case the
                    problem has a primal feasible solution.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_NONE" val="0">
   <cmnt>No interior-point or basic solution are reported when the mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ROOT" val="1">
   <cmnt>The reported interior-point and basic solutions are a solution to the root node problem
                    when mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ITG_REL" val="3">
   <cmnt>In case the problem is primal feasible
                    then the reported interior-point and basic solutions
                    are a solution to the problem with all integer variables
                    fixed at the value they have in the integer solution.
                    If the problem is primal infeasible, then the solution to the root node problem is reported.</cmnt>
  </c>
 </sec>
</constlist>
</mosekvalues>
